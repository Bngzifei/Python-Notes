"""
增量赋值运算符+=和*=的表现取决于它们的第一个操作对象.

+=背后的特殊方法是__iadd__("用于就地加法").但是如果一个类
没有实现这个方法的话,Python会退一步调用__add__.


考虑下面这个简单的表达式:
>>> a += b

如果a实现了__iadd__方法,就会调用这个方法.同时对可变序列(例如list,bytearray和array.array)来说,
a会就地改动,就像调用了a.extend(b)一样.

但是如果a没有实现__iadd__的话,a += b这个表达式的效果就变得跟a = a + b 一样了:

首先计算a + b ,得到一个新的对象,然后赋值给a.也就是说,在这个表达式中,变量名会不会被关联到新的对象,完全取决于
这个类型有没有实现__iadd__这个方法.


总体来讲,可变序列一般都实现了__iadd__方法,因此 += 是就地加法.
而不可变序列根本就不支持这个操作,对这个方法的实现也就无从谈起.

上面所说的这些关于 += 的概念也适用于 *= ,不同的是,后者相对应的是__imul__.


对不可变序列进行重复拼接操作的话,效率会很低,因为每次都有一个新对象,而解释器需要把原来对象中的元素先复制到新的对象里,
然后再追加新的元素.

但是str字符串是一个例外,因为对字符串做 += 实在是太普遍了,所以CPython对它做了优化.为str初始化内存的时候,程序会为它
留出额外的的可扩展空间,因此进行增量操作的时候,并不会涉及复制原有字符串到新位置这类操作.


Python Tutor (http://wwww.pythontutor.com)是一个对Python运行 原理进行可视化分析的工具.

dis库:辅助查看Python运行状态的包.

例如:
import dis
dis.dis("s[a] += b")

就可以看到

s[a] = b背后的字节码执行过程


三个教训:

1.>不要把可变对象放在元组里面

2.>增量赋值不是一个原子操作.刚刚的演示中,它虽然抛出了异常,但还是完成了操作.

3.>查看Python的字节码并不难,而且它对我们了解代码背后的运行机制很有帮助.
"""