"""
推出集成度 初衷是让新手顺利使用只有专家才能设计出来的框架.

本章探讨继承和子类化,重点是说明对Python而言尤为重要的两个细节:
	
	子类化内置类型的缺点
	多重继承和方法解析顺序

很多人觉得多重继承得不偿失.不支持多重继承的Java显然没有什么损失,C++对多重继承的滥用伤害了很多人,这可能还坚定了使用Java的决心.


GUI工具包Tkinter和Web框架Django

	我们将首先分析子类化内置类型的问题.本章余下的内容则探讨多重继承,我们将分析案例,并讨论构建类层次结构方面好的做法和不好的做法.



子类化内置类型很麻烦

	至于内置类型的子类覆盖的方法会不会隐式调用,Cpython没有制定官方规则.基本上,内置类型的方法不会调用子类覆盖的方法.例如,dict的子类覆盖的__getitem__()方法不会被内置类型的get()方法调用.


原生类型的这种行为违背了面向对象编程的一个基本原则:始终应该从实例(self)所属的类开始搜索方法,即使在超类实现的类中调用也是如此.在这种糟糕的局面中,__missing__方法却能按预期方式工作,不过这只是特例.


直接子类化内置类型容易出错,因为内置类型的方法通常会忽略用户覆盖的方法.不要子类化内置类型,用户自己定义的类应该继承collections模块中的类,例如UserDict,UserList和UserString,这些类做了特殊设计,因此易于扩展.

如果不做子类化dict,而是子类化collections.UserDict

若想把方法调用委托给超类(父类),推荐的方式是使用内置的super()函数.
然而,使用super()最安全,也不易过时.调用框架或不受自己控制的类层次结构中的方法时,尤其适合使用super().使用super()调用方法时,会遵守方法解析顺序.



"""