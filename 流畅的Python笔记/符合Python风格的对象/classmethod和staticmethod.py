"""
先来看classmethod.
	定义操作类,而不是操作实例的方法.classmethod改变了调用方法的方式,因此类方法的第一个参数是类本身,而不是实例.classmethod最常见的用途是定义备选构造方法,例如前面示例中的frombytes.注意:frombytes的最后一行使用cls参数构建了一个新实例,即cls(*memv).按照约定,类方法的第一个参数名为cls(但是Python不介意具体怎么命名,即你随意起个名字也行.)


staticmethod装饰器也会改变方法的调用方式,但是第一个参数不是特殊的值.其实,静态方法就是普通的函数,只是碰巧在类的定义体中,而不是在模块层定义.



classmethod装饰器非常有用,但是我从未见过不得不用staticmethod的情况.如果想定义不需要与类交互的函数,那么在模块中定义就好了.有时,函数虽然从不处理类,但是函数的功能与类紧密相关,因此想把它放在近处.即便如此,在同一模块中的类前面或后面定义函数也就行了.

意思就是staticmethod就是一个简单的,普通的函数.不是方法.只不过恰好写在了一个类的定义体中罢了.



格式化显示:

内置的format()函数和str.format()方法把各个类型的格式化方式委托(就是实际调用的是xxx.__format__())给__format__(format_spec)方法.format_spec是格式说明符,它是:
	
	1.>format(my_obj,format_spec)的第二个参数.
	2.>str..format()方法的格式化字符串,{}里面替换字段中冒号后面的部分.



>>> brl = 1/2.43 # BRL到USD的货币兑换比价 
>>> brl 
0.4115226337448559 
>>> format(brl, '0.4f') # ➊ 
'0.4115' 
>>> '1 BRL = {rate:0.2f} USD'.format(rate=brl) # ➋ 
'1 BRL = 0.41 USD'



1.格式说明符是"0.4f"
格式说明符是0.2f.替换字段中的rate字串是字段名称,与格式说明符无关,但是它决定把.format()的哪个参数传给替换字段.

第2条标注指出了一个重要知识点:"{0.mass:5.3e}"这样的格式字符串其实包含两部分,冒号左边的"0.mass"在替换字段句法中是字段名,冒号后面的"5.3e"是格式说明符.格式说明符使用的表示法叫格式规范微语言.

如果你对format()和str.format()都感到陌生,根据我的教学经验.最好先学format()函数,因为它只使用格式规范微语言.学会这些表示法之后,再阅读格式字符串句法,学习str.format()方法使用的{:}替换字段表示法(包含转换标志!s,!r和!a)


格式规范微语言为一些内置类型提供了专用的表示代码.比如,b和x分别表示二进制和十六进制的int类型.f表示小数形式的float类型.而%表示百分数形式:

>>> format(42, 'b') 
'101010' 
>>> format(2/3, '.1%') 
'66.7%'


格式微语言是可扩展的,因为各个类可以自行决定如何解释format_spec参数.例如,datetime模块中的类,它们的__format__方法使用的格式代码与strftime()函数一样.下面是内置的format()函数和str.format()方法的几个示例:


"""
# 为此,我们要把x和y分量设为只读特性:

class Vector2d:
	typecode = "d"

	def __init__(self,x,y):
		self.__x = float(x)  # 使用两个前导下划线,把属性标记为私有的
		self.__y = float(y)

	@property  # @property装饰器把读值方法标记为特性
	def x(self):  # 读值方法与公开属性同名,都是x
		return self._x  # 直接返回self.__x

	@property
	def y(self):
		return self._y

	def __iter__(self):
		return (i for i in (self._x,self._y))

"""
注意:我们让这些向量不可变是有原因的,因为这样才能实现__hash__方法.这个方法应该返回一个整数,理想情况下还要考虑对象属性的散列值(__eq__也要使用),因为相等的对象应该具有相同的散列值.根据特殊方法__hash__的文档,最好使用位运算符异或^混合各分量的散列值.


要想创建可散列的类型,不一定要实现特性,也不一定要保护视力属性.只需要正确地实现__hash__和__eq__方法即可.但是,实例的散列值绝不应该变化,因此我们借机提到了只读特性.

如果定义的类型有标量数值,可能还要实现__int__和__float__方法,分别被int()和float()构造函数调用,以便在某些情况下用于强制转换类型.此外,还有用于支持内置的complex()构造函数的__complex__方法.


小结一下,前两节说明了一些特殊方法,要想得到功能完善的对象,这些方法可能是必备的.当然,如果你的应用用不到,就没必要全部实现这些方法.客户并不关心你的对象是否符合Python风格.

"""