"""
Python不能像Java那样使用private修饰符创建私有属性,但是Python有个简单的机制,能避免子类意外覆盖私有属性.

举个例子.有人编写了一个名为Dog的类,这个类的内部用到了mood实例属性,但是没有将其开放.现在,你创建了Dog类的子类:Beagle.如果你在毫不知情的情况下又创建了名为mood的实例属性,那么在继承的方法中就会把Dog类的mood属性覆盖掉.这是个难以调试的问题.


为了避免这种情况,如果以__mood的形式命名实例属性,Python会把实例属性名存入实例的__dict__属性中,而且会在前面加上一个下划线和类名.因此,对Dog类来说,__mood会变成_Dog__mood:对Beagle类来说,会变成_Beagle__mood.这个语言特性叫名称改写.


名称改写是一种安全措施,不能保证万无一失:它的目的是避免意外访问,不能防止故意做错事.

如图,把手上的盖子是种保护装置,而不是安全装置:它能避免意外触动把手,但是不能防止有意转动.

只要知道改写私有属性名的机制,任何人都能直接读取私有属性----这对调试和序列化倒是有用.此外,只要编写v1._Vector__x=7这样的代码,就能轻松地为Vector2d实例的私有分量直接赋值.如果真在生产环境中这么做了,出问题时可别抱怨.

不是所有Python程序员都喜欢名称改写功能,也不是所有人都喜欢self.__x这种不对称的名称.有些人不喜欢这种句法,他们约定使用一个下划线前缀编写受保护的属性,如self._x.批评使用两个下划线这种改写机制的人认为,应该使用命名约定来避免意外覆盖属性.本章开头引用了多产的Ian Bicking的一句话,那句话的完整表述如下:
	
	绝对不要使用两个前导下划线,这是很烦人的自私行为.如果担心名称冲突,应该明确使用一种名称改写方式(如_MyThing_blahblah).这其实与使用双下划线意义,不过自己定的规则比双下划线易于理解.

	Python解释器不会对使用单个下划线的属性名做特殊处理,不过这是很多Python程序员严格遵守的约定,他们不会在类外部访问这种属性.遵守使用一个下划线标记对象的私有属性很容易,就像遵守使用全大写字母编写常量那样容易.

	备注:

		不过在模块中,顶层名称使用一个前导下划线的话,的确会有影响:对from mymod import * 来说,mymod中前缀为下划线的名称不会被导入.然而,依旧可以使用from mymod import _proivatefunc将其导入.


	Python文档的某些角落把使用一个下划线前缀标记的属性称为受保护的属性.使用self._x这种形式保护属性的做法很常见,但是很少有人把这种属性叫作受保护的属性.有些人甚至将其称为私有属性.

	总之,Vector2d的分量都是私有的,而且Vector2d实例都是不可变的.我用了两对引号,这是因为并不能真正实现私有和不可变.


	在下面我们将讨论一个特殊的属性(不是方法),它会影响对象的内部存储,对内存用量可能也有重大影响.不过对对象的公开接口没有什么影响.这个属性是__slots__.

"""