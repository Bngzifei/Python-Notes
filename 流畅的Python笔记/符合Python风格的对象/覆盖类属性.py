"""
如何在实例和子类中覆盖类属性?

Python有个很独特的特性:类属性可用于为实例属性提供默认值.Vector2d有个typecode类属性,__bytes__方法两次用到了它,而且都故意使用self.typecode读取它的值.因为Vector2d实例本身没有typecode属性,所以self.typecode默认获取的是Vector2d.typecode类属性的值.

但是,如果为不存在的实例属性赋值,会新建实例属性.假如我们为typecode实例属性赋值,那么同名类属性不受影响.然而,自此之后,实例读取的self.typecode是实例属性typecode,也就是把同名类属性遮盖了.借助这一特性,可以为各个实例的typecode属性定制不同的值.


Vector2d.typecode属性的默认值是"d",即转换成字节序列时使用8字节双精度浮点数表示向量的各个分量.如果在转换之前把Vector2d实例的typecode属性设置为"f",
那么使用4字节单精度浮点数表示各个分量.



现在你应该知道为什么要在得到的字节序列前面加上typecode的值了:为了支持不同的格式.

如果想修改类属性的值,必须直接在类上修改,不能通过实例修改.如果想修改所有实例(没有typecode实例变量)的typecode属性的默认值,可以这么做:

	Vector2d.typecode = "f"

然而,有种修改方法更符合Python风格.而且效果持久,也更有针对性.类属性是公开的,因此会被子类继承,于是经常会创建一个子类,只用于定制类的数据属性.Django基于类的视图就大量使用了这个技术.具体做法如示例所示:

from vector2d_v3 import Vector2d
class ShortVector2d(Vector2d):
	typecode = "f"


sv = ShortVector2d(1/11,1/27)
sv

把ShortVector2d定义为Vector2d的子类,只用于覆盖typecode类属性.

为了演示,创建一个ShortVector2d实例,即sv

查看sv的repr表示形式

确认得到的字节序列长度为9字节,而不是之前的17字节.

这也说明了我在Vector2d.__repr__方法中为什么没有硬编码class_name的值,而是使用type(self).__name__获取,如下所示:

# 在Vector2d类中定义

def __repr__(self):
	class_name = type(self).__name__
	return "{}({!r},{!r})".format(class_name,*self)

如果硬编码class_name的值,那么Vector2d的子类(如ShortVector2d)要覆盖__repr__方法,只是为了修改class_name的值,从实例的类型中读取类名,__repr__方法就可以放心继承.


至此,我们通过一个简单的类说明了如何利用数据模型处理Python的其他功能:提供不同的对象表示形式,实现自定义的格式代码,公开只读属性,以及通过hash()函数支持集合和映射.

本章的目的是是说明,如何使用特殊方法和约定的结构,定义行为良好且符合Python风格的类.


符合Python风格的对象应该正好符合所需,而不是堆砌语言特性.


我不断改写Vector2d类时为了提供上下文,以便讨论Python的特殊方法和编程约定.


所有用于获取字符串和字节序列表示形式的方法:

__repr__,__str__,__format__和bytes__

把对象转换成数字的几个方法:__abs__,__bool__和__hash__

用于测试字节序列转换和支持散列连同__hash__方法的__eq__运算符.


为了转换成字节序列,我们还实现了一个备选构造方法,即Vector2d.frombytes(),顺便又讨论了@classmethod(十分有用)和@staticmethod(不太有用,使用模块层函数更简单)两个装饰器.frombytes方法的实现方式借鉴了array.array类中的同名方法.

我们了解到,格式规范微语言是可扩展的,方法是实现__format__得到,对提供给内置函数的format(obj,format_spec)的format_spec,或者提供给str.format方法的"{:<<format_spec>>}"位于代换字段中的<<format_spec>>做简单的解析.


为了把Vector2d实例变成可散列的,我们先让它们不可变,至少要把x和y设为私有属性,再以只读特性公开,以防意外修改它们.随后,我们实现了__hash__方法,使用推荐的异或运算符计算实例属性的散列值.


接着,我们讨论了如何使用__slots__属性节省内存,以及这么做要注意的问题.__slots__属性有点棘手,因此仅当处理特别多的实例(数百万个,而不是几千个)时才建议使用.

最后,我们说明了如何通过访问实例属性(如self.typecode)覆盖类属性.我们先创建一个实例属性,然后创建子类,在类中覆盖类属性.

本章多次提到,我编写代码的方式是为了举例说明如何编写标准Python对象的API如果用一句话总结本章的内容,那就是:

要构建符合Python风格的对象,就要观察真正的Python对象的行为.


__index__方法的作用是强制把对象转换成整数索引,在特定的序列切片场景中使用,以满足NumPy的一个需求.在实际编程中,你我都不用实现__index__方法,除非决定新建一种数值类型,并想把它作为参数传给__getitem__方法.



特性有助于减少前期投入


默认情况下,Python的所有实例属性和类属性都是公开的.这对向量来说是合理的.因为我们要能访问向量.虽然这些向量是可迭代的对象,而且可以拆包成一对变量,但是还要能够通过my_vector.x和myvector.y获取各个分量.

如果觉得应该避免意外更新x和y的属性,可以实现特性,但是代码的其他部分没有变化.Vector2d的公开接口也不受影响,这一点从doctest中可以得知.我们依然能够访问my_vector.x和my_vector.y


Java语言采用的方式则截然相反:Java程序员不能先定义简单的公开属性,然后在需要时再实现特性,因为Java语言没有特性.因此,在Java中编写读值方法和设值方法是常态,就算这些方法没做什么有用的事情也得这么做,因为API不能从简单的公开属性变成读值方法和设值方法,同时又不影响使用那些属性的代码.


建议问这个问题:做这件事最简单的方法是什么?

意即,我们应该把焦点放在目标上,提前实现设值方法和读值方法偏离了目标.在Python中,我们可以先使用公开属性,然后等需要时再变成特性.

私有属性的安全性和保障性


Python和Perl在很多方面的做法是截然相反的,但是Larry和Guido似乎都同意要保护对象的隐私.


我的观点是:Java中的访问控制修饰符基本上也是安全措施,不能保证万无一失----至少实践中是如此.因此,安心享用Python提供的强大功能吧.






"""




