"""
命令模式.这个设计模式也常使用单方法类实现,同样也可以换成普通的函数.

命令模式的目的是解耦调用操作的对象(调用者)和提供实现的对象(接收者).

这个模式的做法是,在二者之间放一个Command对象,让它实现只有一个方法(execute)
的接口,调用接收者中的方法执行所需的操作.这样,调用者无需了解接收者的接口,
而且不同的接收者可以适应不同的Command子类.调用者有一个具体的命令,通过调用
execute方法执行.

命令模式是回调机制的面向对象的替代品.



我们可以不为调用者提供一个Command实例,而是给它一个函数.此时,调用者不用调用
command.execute(),直接调用command()即可.
MacroCommand可以实现成定义了__call__方法的类.这样,MacroCommand的实例就是可调用
对象,各自维护着一个函数列表,供以后使用.


像MacroCommand那样的可调用实例,可以保存任何所需的状态.而且除了__call__之外还可以
提供其他方法.

可以使用闭包在调用之间保存函数的内部状态.

使用一等函数对命令模式的重新审视到此结束.站在一定高度上看,这里采用的方式与策略门槛石所
用的类似:把实现单方法接口的类的实例替换成可调用对象.毕竟,每个Python可调用对象都实现了
单方法的接口,这个方法就是__call__.


很多情况下,在Python中使用函数或可调用对象实现回调更自然.

好的书籍:

<<流畅的Python>>,<<Python Cookbook（第 3 版）中文版>>,

《Python 高级编程》（Tarek Ziadé著）

用 Java 写的设计模式书很多，其中我最喜欢的一本是《Head First 设计 模式》

设计模式与语言特性无法精确对应.


要知道---语言会进化,因此运用经典设计模式的方式必定要随之进化.

"""

# MacroCommand的各个实例都在内部存储着命令列表
class MacroCommand:
	"""一个执行一组命令的命令"""

	def __init__(self,commands):
		# 使用commands参数构建一个列表,这样能确保参数是可迭代对象,
		# 还能在各个MacroCommand实例中保存各个命令引用的副本
		self.commands = list(commands)

	def __call__(self):
		# 调用MacroCommand实例时,self.commands中的各个命令依序执行.
		# 复杂的命令模式(比如撤销操作)可能需要更多,而不仅是简单的回调函数.即便如此,也可以
		# 考虑使用Python提供的几个替代品.
		for command in self.commands:
			command()


