"""
对于Python生成器中的yield来说,yield item这行代码会产出一个值,提供给next(...)的调用方;此外,还会做出让步,
暂停执行生成器,让调用方继续工作,直到需要使用另一个值时再调用next().调用方会从生成器中拉取值.


从句法上看,协程与生成器类似,都是定义体重包含yield关键字的函数.可是,在协程中,yield通常出现在表达式的右边(例如,datun=yield),可以产出值,也可以不产出---如果yield关键字后面没有表达式,那么生成器产出None.协程可能会从调用方接收数据,不过调用方把数据提供给协程使用的是.send(datum)方法,而不是next(...)函数.通常,调用方会把值推送给协程.

yield关键字甚至还可以不接收或传出数据.不管数据如何流动,yield都是一种流程控制工具,使用它可以实现协作式多任务:协程可以把控制器让步给中心调度程序,从而激活其他的协程.

从根本上把yield视作控制流程的方式,这样就好理解协程了.


生成器如何进化成协程?

	生成器的调用方可以使用.send(...)方法发送数据,发送的数据会成为生成器函数中yield表达式的值.因此,生成器可以作为协程使用.协程是指一个过程,这个过程与调用方协作,产出由调用方提供的值.

	
	除了.send(...)方法,还添加了.throw(...)和.close()方法:前者的作用是让调用方抛出异常,在生成器中处理;后者的作用是终止生成器.

	现在,生成器可以返回一个值,以前,如果在生成器中给return语句提供值,会抛出SyntaxError异常.

	新引入了yield from 句法,使用它可以把复杂的生成器重构成小型的嵌套生成器,省去了之前把生成器的工作委托给子生成器所需的大量样板代码.
	
	协程可以身处四个状态中的一个.当前状态可以使用inspect.getgeneratorstate(...)函数确定,该函数会返回下述字符串中的一个.

	"GEN_CREATE"
		等待开始执行

	"GEN_RUNNING"
		解释器正在执行

	"GEN_SUSPENDED"
		在yield表达式处暂停

	"GEN_CLOSED"
		执行结束

	因为send方法的参数会成为暂停的yield表达式的值,所以,仅当协程处于暂停状态时才能调用send方法,例如my_coro.send(42).不过,如果协程还没激活(即,状态是"GEN_CREATE"),情况就不同了.因此,始终要调用next(my_coro)激活协程---也可以调用my_coro.send(None),效果一样.

	最先调用next(my_coro)函数这一步通常称为"预激协程(即,让协程向前执行到第一个yield表达式,准备好作为活跃的协程使用)"


产出两个值的协程
>>>def simple_coro2(a):
	print("-> Started:a = ",a)
	b = yield a
	print("-> Received: b =",b)
	c = yield a + b
	print("-> Received: c =",c)



"""