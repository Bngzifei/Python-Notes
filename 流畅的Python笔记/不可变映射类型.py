"""
不可变映射类型:

	标准库里所有的映射类型都是可变的,但有时候你会有这样的需求,比如不能让用户错误地修改某个映射.


	从Python3.3开始,types模块引入了一个封装类名叫MappingProxyType.如果给这个类一个映射,它会
	返回一个只读的映射视图.虽然是个只读视图,但是它是动态的.这意味着如果对原映射做出了改动,我们
	通过这个视图可以观察到,但是无法通过这个视图对原映射做出修改.


"""

# 用MappingProxyType来获取字典的只读实例mappingproxy
from types import MappingProxyType

d = {1:"A"}
d_proxy = MappingProxyType(d)
print(d_proxy)  # mappingproxy({1: 'A'})  
print(d_proxy[1])
# d_proxy[2] = "x"
d[2] = "B"


"""
说明:
	d中的内容可以通过d_proxy看到

	但是通过d_proxy并不能做任何修改

	d_proxy是动态的,也就是说对d所做的任何改动都会反馈到它上面

	Python2.7里面并没有这个类型.只在Python3.3后才有

"""



"""
集合论:
	
	集合的本质是许多唯一对象的聚集.

	集合中的元素必须是可散列的.set类型本身是不可散列的,但是frozenset可以.因此可以创建一个包含不同
	frozenset的set.
	
	保证唯一性.(就是有去重的功能)

	如果是空集,必须写成set()的形式.必须用不带任何参数的构造方法set().如果只是写成{}的形式,跟以前一样,创建
	的其实是个空字典.

	在Python3里面,除了空集,集合的字符串表示形式总是以{...}的形式出现.

集合字面量:
	
	像{1,2,3}这种字面量句法相比于构造方法(set([1,2,3]))要更快且更易读.后者(构造方法的形式)的速度要慢一些,因为
	Python必须先从set这个名字来查询构造方法,然后新建一个列表,最后再把这个列表传入到构造方法里.但是如果是像{1,2,3}
	这样的字面量,Python会利用一个专门的叫作BUILD_SET的字节码来创建集合.

	字节码（Byte-code）是一种包含执行程序、由一序列 op 代码/数据对组成的二进制文件。字节码是一种中间码，它比机器码更抽象。
	它经常被看作是包含一个执行程序的二进制文件，更像一个对象模型。字节码被这样叫是因为通常每个 
	opcode 是一字节长，但是指令码的长度是变化的。每个指令有从 0 到 255（或十六进制的： 00 到FF)的一字节操作码，
	被参数例如寄存器或内存地址跟随。



由于Python里没有针对frozenset的特殊字面量语法,我们只能采用构造方法.Python3里frozenset的标准字符串表示形式看起来就像构造方法
调用一样.比如:
	frozenset(range(10))
	输出:frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})


	中缀运算符需要两侧的被操作对象都是集合类型,但是其他的所有方法则只要求所传入的参数是可迭代对象.例如:
	求4个聚合类型a,b,c和d的合集,可以用a.union(b,c,d),这里a必须是个set,但是b,c,d则可以是任何类型的可迭代对象.




"""
print("**************>>>")
# 用dis.dis(反汇编函数)来看看两个方法的字节码的不同:
from dis import dis


# 字面量形式:
dis("{1}")
"""
 1            0 LOAD_CONST               0 (1)    检查{1}字面量背后的字节码
              2 BUILD_SET                1        特殊的字节码BUILD_SET几乎完成了所有的工作
              4 RETURN_VALUE
"""




# 构造方法星宿
dis("set([1])")
"""
1             0 LOAD_NAME                0 (set)  set([1])的字节码:3种不同的操作代替了上面的BUILD_SET:LOAD_NAME,BUILD_LIST,CALL_FUNCTION
              2 LOAD_CONST               0 (1)
              4 BUILD_LIST               1
              6 CALL_FUNCTION            1
              8 RETURN_VALUE
"""

"""
dict和set的背后

字典中的散列表:
	
	散列表其实是一个稀疏数组(总是有空白元素的数组称为稀疏数组).在一般的数据结构教材中,散列表里的单元通常叫作  表元(bucket)
	在dict的散列表当中,每个键值对都占用一个表元,每个表元都有两个部分,一个是对键的引用,另一个是对值的引用.因为所有表元的大小
	一致,所以可以通过偏移量来读取某个表元.

	因为Python会设法保证大概还有三分之一的表元是空的.所以在快要达到这个阈值的时候,原有的散列表会被复制到一个更大的空间里面.
	如果要把一个对象放入散列表,那么首先要计算这个元素键的散列值.Python中可以使用hash()方法来做这件事情.


散列值和相等性
	
	内置的hash()方法可以用于所有的内置类型对象.如果是自定义对象调用hash()的话,实际上运行的是自定义的__hash__.如果两个对象在比较的时候是相等的,那它们的散列值
	必须相等,否则散列表就不能正常运行了.例如,如果1 == 1.0为真,那么hash(1) == hash(1.0)也必须为真,但其实这两个数字(整型和浮点)的内部结构是完全不一样的.


	为了让散列值能够胜任散列表索引这一角色,它们必须在索引空间中尽量分散开来.这意味着在最理想的状况下,越是相似但不相等的对象,他们散列值的差别应该越大.

	从Python3.3开始,str,bytes,和datetime对象的散列值计算过程中多了随机加盐这一步.所加盐值是Python进程内的一个常量,但是每次启动Python解释器都会生成一个不同的盐值.
	随机盐值的加入是为了防止DOS攻击而采取的一种安全措施.



散列表算法:
	
	为了获取my_dict[search_key]背后的值,Python首先会调用hash(search_key)来计算search_key的散列值,把这个值最低的几位数字当作偏移量,在散列表里查找元(具体取几位,得看当前散列表的大小)
	若找到的表元是空的,则抛出KeyError异常.若不是空的,则表元里会有一对found_key:found_value.这时候Python会检验search_key == found_key是否为真,如果它们相等的话,就会返回found_value.

	如果search_key和found_key不匹配的话,这种情况称为散列冲突.发生这种情况是因为,散列表所做的其实是把随机的元素映射到只有几位的数字上,而散列表本身的索引又只依赖于这个数字的一部分.为了
	解决散列冲突,算法会在散列值中另外再取几位,然后用特殊的方法处理一下,把新得到的数字再当作索引来寻找表元.若这次找到的表元是空的,则同样抛出KeyError;若非空,或者键匹配,则返回这个值.
	或者又发现了散列冲突,则重复以上的步骤.

添加新元素和更新现有键值的操作几乎跟上面一样.只不过对于前者,在发现空表元的时候会放入一个新元素;对于后者,在找到相对应的表元后,原表里的值对象会被替换成新值.

另外在插入新值时,Python可能会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容.如果增加了散列表的大小,那散列值所占的位数和用作索引的位数都会随之增加,
这样做的目的是为了减少发生散列冲突的概率.

表面上看,这个算法似乎很费事,而实际上就算dict里有数百万个元素,多数的搜索过程中并不会有冲突发生,平均下来每次搜索可能会有一到两次冲突.在正常情况下,就算是最不走运的键所遇到的冲突的次数用一只手
也能数过来.

dict的实现及其导致的结果:
	
	1.>键必须是可散列的

	一个可散列的对象必须满足以下要求:
		1.支持hash()函数,并且通过__hash__()方法所得到的散列值是不变的.
		2.支持通过__eq__()方法来检测相等性
		3.若a == b为真,则hash(a)==hash(b)也为真
	所有由用户自定义的对象默认都是可散列的,因为它们的散列值由id()来获取,而且它们都是不相等的.

	说明:
		如果你实现了一个类的__eq__方法,并且希望它是可散列的,那么它一定要有个恰当的__hash__方法,保证在a==b为真的情况下hash(a)==hash(b)也必定为真.否则就会破坏恒定的散列表算法,导致由这些对象所组成
		的字典和集合完全失去可靠性,这个后果是非常可怕的.另一方面,如果一个含有自定义的__eq__依赖的类处于可变的状态,那就不要在这个类中实现__hash__方法,因为它的实例是不可散列的.

	2.>字典在内存上的开销巨大

		由于字典使用了散列表,而散列表又必须是稀疏的,这导致它在空间上的效率低下.举例而言,如果你需要存放数量巨大的记录,那么放在由元组或是具名元组构成的列表中会是比较好的选择;最好不要根据JSON的风格,用
		由字典组成的列表来存放这些记录.用元组取代字典就能节省空间的原因有两个:其一是避免了散列表所耗费的空间,其二是无需把记录中字段的名字在每个元素里都存一遍.

		在用户自定义的类型中,__slots__属性可以改变实例属性的存储方式,由dict变成tuple.

		记住我们现在讨论的是空间优化.如果你手头有几百万个对象,而你的机器有几个GB的内存,那么空间的优化工作可以等到真正需要的时候再开始计划,因为优化往往是可维护性的对立面.

	3.>键查询很快

		dict的实现是典型的空间换时间:字典类型有着巨大的内存开销,但它们提供了无视数据量大小的快速访问----只要字典能被撞在内存里.这意味着在一个有1000万个元素的字典里,每秒能进行200万个键查询.

	4.>键的次序取决于添加顺序

		当往dict里添加新键而又发生散列冲突的时候,新键可能会被安排存放到另一个位置.

	5.>往字典里添加新键可能会改变已有键的顺序

		无论何时往字典里添加新的键,Python解释器都可能做出为字典扩容的决定.扩容导致的结果就是要新建一个更大的散列表,并把字典里已有的元素添加到新表里.这个过程中可能会发生新的散列冲突,导致新散列表中键的次序
		发生变化.要注意的是,上面提到的这些变化是否会发生以及如何发生,都依赖于字典背后的具体实现,因此你不能很自信地说自己知道背后发生了什么.如果你在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个
		循环很有可能会跳过一些键-----甚至是跳过那些字典中已经有的键.

		由此可知,不要对字典同时进行迭代和修改.如果像扫描并修改一个字典,最好分成两步来进行:首先对字典迭代,以得出需要添加的内容,把这些内容放在一个新字典里;迭代结束之后再对原有字典进行更新.

		在Python3中,.keys(),.items()和.values()方法返回的都是字典视图.也就是说,这些方法返回的值更像集合,而不是像Python2那样返回列表一样.视图还有动态的特性,它们可以实时反馈字典的变化.



set的实现以及导致的结果:
	
	set和frozenset的实现也依赖散列表,但是它们的散列表里面存放的只有元素的引用(就像字典里只存放键而没有相应的值).在set加入到Python之前,我们都是把字典加上无意义的值当作集合来用的.
	

	1.>集合里的元素必须是可散列的


	2.>集合很消耗内存


	3.>可以很高效地判断元素是否存在于某个集合


	4.>元素的次序取决于被添加到集合里的次序


	5.>往集合里添加元素,可能会改变集合里已有元素的次序

总结:
	
	大多数映射类型都提供了两个很强大的方法:setdefault和update.
	setdefault方法可以用来更新字典里存放的可变值(比如列表),从而避免了重复的键搜索.
	update方法则让批量更新成为可能,它可以用来插入新值或者更新已有键值对,它的参数可以是包含(key,value)这种键值对的可迭代对象,或者关键字参数.映射类型的构造方法也会利用update方法来让用户可以使用别的映射对象,
	可迭代对象或者关键字参数类创建新对象.

"""