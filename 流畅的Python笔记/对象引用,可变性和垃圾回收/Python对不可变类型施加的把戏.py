"""
我惊讶的发现,对元组t来说,t[:]不创建副本,而是返回同一个对象的引用.

此外,tuple(t)获得的也是同一个元组的引用.

文档明确指出了这个行为.在Python控制台中输入help(tuple),你会看到这句话,如果参数是一个元组,那么返回值是同一个对象

使用另一个元组构建元组,得到的其实是同一个元组.

str,bytes和frozenset实例也有这种行为.注意,frozenset实例不是序列,因此不能使用fs[:](fs是一个frozenset实例).但是,fs.copy()具有同样的效果:它会欺骗你,返回同一个对象的引用,而不是创建一个副本.

copy方法不会复制所有对象,这是一个善意的谎言,为的是接口的兼容性:这使得frozenset的兼容性比set强.两个不可变对象是同一个对象还是副本,反正对最终用户来说没有区别.


共享字符串字面量是一种优化措施,成为驻留(interning).CPython还会在小的整数上使用这个优化措施,防止重复创建"热门"数字,如0,-1,和42.注意,CPython不会驻留所有字符串和整数,驻留的条件是实现细节,而且没有文档说明.

千万不要依赖字符串或整数的驻留!!!比较字符串或整数是否相等时,应该使用==,而不是is.驻留是Python解释器内部使用的一个特性.

本节讨论的把戏,包括frozenset.copy()的行为,是善意的谎言,能节省内存,提升解释器的速度.别担心,它们不会为你带来任何麻烦,因为只有不可变类型会受到影响.或许这些细枝末节的最佳用途是与其他Python程序员打赌,提高自己的胜算.

每个Python对象都有标识,类型和值.只有对象的值会不时变化.

其实,对象的类型也可以变,方法只有一种:为__class__属性指定其他类.但这是在作恶.


如果两个变量指代的不可变对象具有相同的值(a == b为True),实际上它们指代的是副本还是同一个对象的别名基本没什么关系,因为不可变对象的值不会变.但有一个例外.这里说的例外是不可变的集合,如元组和frozenset:如果不可变集合保存的是可变元素的引用,那么可变元素的值发生变化后,不可变集合也会随之改变.实际上,这种情况不是很常见.不可变集合不变的是所含对象的标识.


变量保存的是引用,这一点对Python编程有很多实际的影响.

简单的赋值不创建副本

对+=或*=所做的增量赋值来说,如果左边的变量绑定的是不可变对象,会创建新对象;如果是可变对象,会就地修改.

为现有的变量赋予新值,不会修改之前绑定的变量.这叫重新绑定:现在变量绑定了其他对象.如果变量是之前那个对象的最后一个引用,对象会被当作垃圾回收.


函数的参数以别名的形式传递,这意味着,函数可能会修改通过参数传入的可变对象.这一行为无法避免.除非在本地创建副本,或者使用不可变对象(例如,传入元组,而不传入列表).

使用可变类型作为函数参数的默认值有危险.因为如果就地修改了参数,默认值也就变了,这会影响以后使用默认值的调用.


在CPython中,对象的引用数量归零后,对象会被立即销毁.如果除了循环引用之外没有其他引用,两个对象都会被销毁.某些情况下,可能需要保存对象的引用,但不留存对象本身.例如,有一个类想要记录所有实例.这个需要可以使用弱引用实现.这是一种低层机制,是weakref模块中的WeakValueDictionary,WeakKeyDictionary和WeakSet等有用的集合类,以及finalize函数的底层支持.


垃圾回收程序是一种实现的特性,其行为在不同的Python解释器中有所不同.例如,Jython用的是Java垃圾回收程序.

可变性:

	如果所有Python对象都是不可变的,那么本章就没有存在的必要了.处理不可变对象时,变量保存的是真正的对象还是共享对象的引用无关紧要.如果a == b 成立,而且两个对象都不会变,那么它们就可能是相同的对象.这就是为什么字符串可以安全使用驻留.仅当对象可变时,对象标识才重要.


	在"纯"函数式编程中,所有数据都是不可变的.如果为集合追加元素,那么其实会创建新的集合.然而,Python不是函数式语言,更别提纯不纯了.在Python中,用户定义的类,其实例默认可变(多数面向对象语言都是如此).自己创建对象时,如果需要不可变的对象,一定要格外小心.此时,对象的每个属性都必须是不可变的,否则会出现类似元组那种行为:元组本身不可变,但是如果里面保存着可变对象,那么元组的值可能会变.


	可变对象还是导致多线程编程难以处理的主要原因,因为某个线程改动对象后,如果不正确地同步,那就会损坏数据.但是过度同步又会导致死锁.


对象析构和垃圾回收:
	
	Python没有直接销毁对象的机制,这一疏漏其实是一个好的特性:如果随时可以销毁对象,那么指向对象的强引用怎么办?

	CPython中的垃圾回收主要依靠引用计数,这容易实现,但是遇到引用循环容易泄露内存.因此CPython2.0实现了分代垃圾回收程序,它能把引用循环中的不可获取的对象销毁.


	但是引用计数仍然作为一种基准存在,一旦引用数量归零,就立即销毁对象.这意味着,在CPython中,这样写是安全的.
		open("test.txt","wt",encoding="utf-8").write("1,2,3")
	
	这行代码是安全的,因为文件对象的引用数量会在write方法返回后归零.Python在销毁内存中表示文件的对象之前,会立即关闭文件.然而,这行代码在Jython或IronPython中却不安全,因为它们使用的宿主运行时(Java VM和.NET CLR)中的垃圾回收程序,那些回收程序更复杂,但是不依靠引用计数,而且销毁对象和关闭文件的时间可能更长.在任何情况下,包括CPython,最好显示关闭文件;而关闭文件的最可靠方式是使用with语句,它能保证文件一定会被关闭.即使打开文件时抛出了异常也无妨.使用with,上述代码变成了:

	with open("test.txt","wt",encoding="utf-8") as fp:
		fp.write("1,2,3")


参数传递:共享传参

	解释Python中参数传递的方式时,人们经常这样说:"参数按值传递,但是这里的值是引用."这么说没错,但是会引起误解,因为在旧式语言中,最常用的参数传递模式有按值传递(函数得到参数的副本)和按引用传递(函数得到参数的指针)在Python中,函数得到参数的副本,但是参数始终是引用.因此,如果参数引用的是可变对象,那么对象可能会被修改,但是对象的标识不变.此外,因为函数得到的是参数引用的副本,所以重新绑定对函数外部没有影响.



































"""
