"""
首先,我们要抛弃变量是存储数据的盒子这一错误观念.

人们经常使用"变量是盒子"这样的比喻,但是这有碍于理解面向对象语言中的引用式变量.

Python变量类似于Java中的引用式变量,因此最好把它们理解为附加在对象上的标注.


赋值语句的右边先执行


创建对象之后才会把变量分配给对象:
"""

class Gizmo:
	
	def __init__(self):
		print("Gizmo id:%d" % id(self))

x = Gizmo()  # Gizmo id:4836624  输出的Gizmo id 是创建Gizmo实例的副作用
y = Gizmo() * 10  # Gizmo id:5155888  # 在乘法运算中Gizmo实例会抛出异常.

"""
这里表明,在尝试求积之前其实会创建一个新的Gizmo实例,但是,肯定不会创建变量y,因为在对赋值语句
的右边进行求值时抛出了异常.

为了理解Python中的赋值语句,应该始终先读右边.对象在右边创建或获取,在此之后左边的变量才会绑定
到对象上,这就像对对象贴上标注.忘掉盒子吧!

因为变量只不过是标注,所以无法阻止为对象贴上多个标注.贴的多个标注,就是别名.
"""



"""
标识,相等性和别名

alex指代的对象与赋值给charse的对象内容一样.比较两个对象,结果相等,这是因为dict类的__eq__
方法就是这样实现的.但它们时不同的对象.这是Python说明标识不同的方式:a is not b

alex和charse绑定的对象具有相同的值==比较的就是值,但是它们的标识不同.


每个变量都有标识,类型和值.对象一旦创建,它的标识绝不会变;你可以把标识理解为对象在内存中的地址.is
运算符比较两个对象的标识;id()函数返回对象标识的整数表示.

对象ID的真正意义在不同的实现中有所不同.在CPython中,id()返回对象的内存地址,但是在其他Python解释器
中可能是别的值.关键是,ID一定时唯一的数值标注,而且在对象的生命周期中绝不会变.其实,编程中很少使用id()
函数.标识最常使用id运算符检查,而不是直接比较ID .



在==和is之间选择

==运算符比较两个对象的值(对象中保存的数据).而is比较对象的标识.

通常,我们关注的是值,而不是标识.因此Python代码中==出现的频率比is高.

然而,在变量和单例值之间比较时,应该使用is.目前,最常使用is检查变量绑定的值
是不是None.下面是推荐的写法:
x is None
否定的正确写法:  x is not None

is运算符比==速度快,因为它不能重载,所以Python不用寻找并调用特殊方法,而是直接比较两个整数ID.而a == b
是语法糖,等同于a.__eq__(b).继承自objectde __eq__方法比较两个对象的ID,结果与is一样.但是多数内置类型
使用更有意义的方式覆盖了__eq__方法,会考虑对象属性的值.相等性测试可能涉及大量处理工作,例如,比较大型集合
或嵌套层级深的结构时.



元组的相对不可变性:

元组与多数Python集合(列表,字典,集等等)一样,保存的是对象的引用.如果引用的元素是可变的,即便元组本身不可变.
元素依然可变.也就是说,元组的不可变性其实是指tuple数据结构的物理内容(即保存的引用)不可变,与引用的对象无关.
而str,bytes和array.array等单一类型序列是扁平的,它们保存的不是引用,而是在连续的内存中保存数据本身(字符,字节
和数字)

元组的值会随着引用的可变对象的变化而变,元组中不可变的是元素的标识.


复制对象时,相等性和标识之间的区别有更深入的影响.副本与源对象相等,但是ID不同.可是,如果对象中包含其他对象,那么应该
复制内部对象吗,可以共享内部对象吗?这些问题没有唯一的答案.


默认做浅复制:

	复制列表(或多数内置的可变集合)最简单的方式是使用内置的类型构造方法.

	list(l1)创建l1的副本
	副本与源列表相等
	但是二者指代不同的对象.对列表和其他可变序列来说,还能使用简洁的l2 = l1[:]语句创建副本.

	然而,构造方法或[:]做的是浅复制(即复制了最外层容器,副本中的元素是源容器中元素的引用.)如果所有元素都是不可变的,那么这
	样没有问题,还能节省内存.但是,如果有可变的元素,可能就会导致意想不到的问题.

为任意对象做深复制和浅复制

浅复制没什么问题,但是我们需要的是深复制(即副本不共享内部对象的引用).

注意:一般来说,深复制不是件简单的事.如果对象有循环引用,那么这个朴素的算法会进入无限循环.deepcopy函数会记住已经复制的对象,
因此能优雅地处理循环引用.

此外,深复制有时可能太深了.例如,对象可能会引用不该复制的外部资源或单例值.我们可以实现特殊方法__copy__()和__deepcopy__(),
控制copy和deepcopy的行为.

通过别名共享对象还能解释Python中传递参数的方式,以及使用可变类型作为参数默认值引起的问题.

"""

