"""
del和垃圾回收
    对象绝不会自行销毁,然而.,无法得到对象时,可能会被当做垃圾回收.

del 语句删除名称,而不是对象.del命令可能会导致对象当做垃圾回收,但是仅当删除的变量保存的是对象的最后一个引用,或者无法得到对象时.重新绑定也可能会导致对象的引用数量归零,导致对象被销毁.


注:如果两个对象相互引用,当它们的引用只存在二者之间时,垃圾回收程序会判定它们都无法获取,进而把它们都销毁.


有个特殊的__del__特殊方法,但是它不会销毁实例,不应该在代码中调用.即将销毁实例时,Python解释器会调用__del__方法,给实例最后的机会,释放外部资源.自己编写的代码很少需要实现__del__代码,有些Python新手会花时间实现,但却吃力不讨好,因为__del__很难用对.



在Cpython中,垃圾回收使用的主要算法是引用计数.实际上,每个对象都会统计有多少引用指向自己.当引用计算归零时,对象立即就被销毁:Cpython会在对象上调用__del__方法(如果定义了),然后释放分配给对象的内存.CPython2.0增加了分代垃圾回收算法,用于检测引用循环中涉及的对象组---如果一组对象之间全是相互引用,即使再出色的引用方式也会导致组中的对象不可获取.Python的其他市县有更复杂的垃圾回收程序,而且不依赖引用计数,这意味着,对象的引用数量为零时可能不会立即调用__del__方法.


为了演示对象生命结束时的情形,下面使用weakref.finalize注册一个回调函数,在销毁对象时调用.

1.>没有指向对象的引用时,监视对象生命结束时的情形:
"""

import weakref

s1 = {1,2,3}

s2 = s1  # s1和s2是别名,指向同一个集合,{1,2,3}


def bye():  # 这个函数一定不能是要销毁的对象的绑定方法,否则会有一个指向对象的引用.
	print("Gone with wind...")

ender = weakref.finalize(s1,bye)  # 在s1引用的对象上注册bye回调
ender.alive  # True  调用finalize对象之前,alive属性的值为True
del s1 
ender.alive  # True  如前所述,del不是删除对象,而是删除对象的引用.
s2 = "spam"  # Gone with wind...  重新绑定最后一个引用s2,让{1,2,3}无法获取.对象被销毁了,调用了bye回调,ender.alive的值变成了False
ender.alive  # False

"""
你可能觉得奇怪,为什么示例中的{1,2,3}对象被销毁了?毕竟,我们把s1引用传给finalize函数了,而为了监控对象和调用回调,必须要有引用.这是因为,finalize持有{1,2,3的弱引用}

"""


