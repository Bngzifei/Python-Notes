"""
基础班是会用
面试是必问的
函数名<也是一个对象>就是指向函数代码的引用.
对象既可以把引用传给别人,也能接收别人的引用

函数名的意义:
1.>就是存有函数代码空间的引用的对象
2.>对象可以将引用传递给其他对象
3.>该对象可以接收来自其他对象的引用
"""
# ------------------------------------示例------------------------------->
# l = lambda x:x+100
# func = l
# print(func(12))

# 底层 C C++ js


# 应用:调用底层的,使用底层的  因为Python有其他语言的很多写好的库,直接调用就可以

# def f1():
# 	# print('正在检查1,2,3,4...')
# 	print('in f1')
# 迭代 改进 增加
# ---------------------------------业务需要增加安全检查功能-------------->
# f1()

# 可以加一个函数专门来实现所需要的新功能,然后在每个函数中添加这个新功能,这种还可以

# 最好的办法是装饰器这种
# ---------------------开闭原则-------------------------------->
"""
1.>开闭原则
	1.>对已经实现了的代码是关闭的, 不允许的.
	2.>对 功能扩展是开放的,允许的
	
总结起来就是:在不修改原有代码的情况下添加了新的功能

"""


def check(func):  # check就是装饰器函数.func是一个形参,位置形参
	def inner():
		print('正在检查 ing 123')
		print('即将开始运行func')
		func()  # 保留了f1的引用
		print('已经运行完成了')

	return inner


def check1(*args, **kwargs):  # check就是装饰器函数.func是一个形参,位置形参
	"""虽然函数形式上可以接收多个参数,但是在装饰器中只能接收一个参数<被装饰的函数的函数名>"""
	func = args[0]

	def inner():
		print('正在检查')
		func()  # 保留了f1的引用

	return inner


# @装饰器语法  就是对 函数名= 装饰器函数<函数名> 的封装
@check  # 记住:是在定义函数的上边一行,不是在调用函数的时候加
def f1():
	print('running in f1')


"""等价于下面:
@check
def f1():
	pass
f1 = check(f1)   灵魂代码   完成对f1的装饰


问题:
	1.>本行中的f1还是原来的f1对象吗?  
	不是,是check函数的返回值内部函数的引用
		
	2.>check函数中的func参数的意义
	func是一个参数,来接收被装饰的函数的函数名.
	
特点:
"""

# 装饰器函数是基于闭包实现的,<嵌套,返回内部引用,环境变量>
# 装饰器的目的:不修改原有代码的情况下,进行新功能的扩展
# 装饰器函数的特点:
# 把f1装饰成  f2
# f2 = check(f1)  # 把f1函数给check传进去,让他去处理f1
# f2()
# 直接换成f1也行,就是把f1原来引用换到了f2
# f1 = check(f1)  # 把f1函数给check传进去,让他去处理f1
# f1()

f1()

"""
应用场景:
1.程序日志
2.函数运行时间
3.执行函数前的预备处理<安全检查>
4.执行函数后的清理处理
5.权限校验
6.缓存  见前面的例子

"""
