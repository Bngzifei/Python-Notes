print('---------------数据库高级应用----------------')
"""
视图:因为对于复杂的查询,往往是有多个数据表进行关联查询而得到的,而这种语句往往比较复杂,也可能非常频繁的使用.
所以,为了简化用户复杂的操作,我们可以考虑使用视图.

视图:就是一个能够把复杂sql语句的功能封装起来的一个虚表,所以我们在创建视图的时候,主要的工作就落在创建这条sql查询语句上.

视图是对若干张基本表的引用,一整虚表,只查询语句执行结果的字段类型和约束,不存储具体的数据,<基本表数据发生了改变,视图也会跟着改变>

优点:方便操作,特别是查询操作.减少复杂的sql语句,增强可读性.

"""

"""
定义视图:建议以v_开头  

作用:视图就是拿来查询的,简化操作

总结:视图封装了对多张基本表的复杂操作,简化用户操作.
视图只是一个虚表,并不存储任何基本表数据.当用户使用视图的时候,视图会从基本表
中取出
通过视图可以对用户展示指定字段从而屏蔽其他字段数据,更加安全
"""

"""事务:
Transaction:事务,交易
事务Transaction .是指作为一个基本工作单元执行的一系列sql语句的操作.要么
完全的执行,要么完全的都不执行.

从一个账号扣款并使另外一个账号增款,这两个操作要么都执行,要么都不执行.
这两个操作必须保证全部成功或者什么也不做,不允许出现成功1个失败一个的情况.

事务的四大特性:ACID

原子性:atomicity
一致性:consistency
隔离性:isolation
持久性:durability

回滚:就是撤销的意思.即取消之前所有的操作.

一个很好的事务处理系统,必须具备这些标准特性.


1.>原子性:atomicity
一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚.对于一个事务来说,不可能只执行其中的一部分操作.这就是事务的原子性.

2.一致性:consistency
数据库总是从一个一致性的状态转换到另一个一致性的状态

3.隔离性:isolation
通常来说,一个事务所做的修改是在最终提交之前,对其他事务是不可见的. 

4.持久性:durability
一旦事务提交,则其所有的修改会永久保存到数据库<此时即使系统奔溃,修改的数据也不会
丢失>


注意:表的引擎类型必须是innodb类型才可以使用事务,这是mysql表的默认引擎.

开启事务后执行修改命令,变更会维护到本地缓存中,而不是维护到物理表中.



1.>开启事务:begin;或者start transaction;

2.>提交事务: commit 将缓存中的数据变更维护到物理表中

3.>回滚事务: rollback 放弃缓存中变更的数据,表示事务执行失败,应该回到开始事务前的状态


验证事务的acid特性:

1.验证提交   

事务具有原子性,一致性,隔离性,持久性.

原子性强调事务中的多个操作时一个整体

一致性强调数据库中不会保存不一致的状态
隔离性强调数据库中事务之间相互不可见
持久性强调数据库能永久保存数据,一旦提交就不可以撤销

关于事务方面需要注意的几个问题:
1.>修改数据的命令会自动的触发事务,包括Insert,update,delete
2.>在mysql命令行中会自动提交事务,所以当我insert语句执行完成后没有commit数据库
也看到了提交的数据
3.>当我们不需要mysql命令行自动提交的时候,键入set autocommit=0即可
4.>sql语句中有手动开启事务的原因是:可以进行多次数据的修改,如果成功一起成功,否则一起回滚到之前的数据
5.>不可撤销的操作<隐式提交>:除了对表数据insert/update/delete语句之外的绝大多数语句都是不能撤销的,比如数据库,表结构的操作.

"""
# ---------------------------------索引------------------------------->
"""
一般的应用系统对比数据库的读写比例在10:1左右<即有10次查询操作时就有1次写的操作>

而且插入操作和更新操作很少出现性能问题.
遇到最多,最容易出问题还是一些复杂的查询操作.所以查询语句的优化显然是重中之重,
当数据库中数据量很大的时候,查找数据会变得很慢,我们就可以使用索引来提高数据库的查询效率.

索引:索引是一种特殊的文件<innoDB数据表上的索引是表空间的一个组成部分>,它们包含着对数据表里所有记录的位置信息.

原理:通过不断的缩小想要获得数据的范围来筛选出最终想要的结果,同时把随机的事件变成顺序的事件,也就是说我们总是通过同一种查找方式来锁定数据.

创建索引:如果指定字段是字符串,需要指定长度,建议长度与定义字段时候的长度一致
字段类型如果不是字符串,可以不填写长度部分

"""

# from pymysql import connect
#
#
# def main():
# 	# 创建connection连接
# 	conn = connect(host='localhost', port=3306, database='jing_dong', user='root', password='password', charset='utf8')
# 	# 获得cursor对象
# 	cursor = conn.cursor()
# 	# 插入10万次数据
# 	for i in range(100000):
# 		cursor.execute("insert into test_index VALUES ('ha-%d')" % i)
# 	# 提交数据
# 	conn.commit()
#
#
# if __name__ == '__main__':
# 	main()

"""总结:
索引可以明显提高某些字段的查询效率
索引使用:
创建create index xxx on 表名(字段名[索引长度 字符串类型才需要指定])
CREATE index title_index on test_index(title(10));

查看show index for xxx

索引的副作用:索引虽好,不要贪杯

注意:建立太多的所有将会影响更新和插入的速度,因为他需要同样更新每个索引文件.对于一个经常需要更新和插入的表格,就没有必要为一个很少使用的where字句单独建立索引了.对于比较小的表,排序的开销不会很大,也没有必要建立另外的索引.
建立索引会占用磁盘空间.

"""
# --------------------------------账户管理---------------------->
"""
如果在生产环境下操作数据库的时候也是全部直接使用root账户连接,这就和悬崖边跳舞差不多.所以创建特定的账户,授予这个账户特定的操作权限,然后连接进行操作.比如常规的crud才是正道.
Mysql账户体系:根据账户所具有的权限的不同,mysql的账户可以分为以下几种:
服务实例级账号:启动了一个mysqld,即为一个数据库实例,如果某用户如root拥有服务实例级分配的权限,那么该账户就可以删除所有的数据库,以及连同这些库中的表.

数据库级别账号:对特定的数据库执行增删改查的所有操作.
数据库表级别账号:对特定表执行增删改查等所有操作.
字段级别的权限:对某些表的特定字段进行操作.
存储程序级别的账号:对存储程序进行增删改查的操作.

注意:进行账户操作的时候,需要使用root账户登录,这个账户拥有最高的实例级权限.账户的操作主要包括创建账户,删除账户,修改密码,授权权限等等.

"""
"""
授予权限:
需要使用实例级账户登录后操作,以root为例:
主要操作包括:
查看所有用户:
修改密码
删除用户

注意:所有用户及权限信息都存储在mysql数据库的user表中.
desc user;
主要字段说明:
Host表示允许访问的主机,
User表示用户名
authentication_string表示密码,为加密后的值

select host,user,authentication_string from user;
+-----------+------------------+-------------------------------------------+
| host      | user             | authentication_string                     |
+-----------+------------------+-------------------------------------------+
| localhost | root             | *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA |
| localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| localhost | debian-sys-maint | *EFED9C764966EDB33BB7318E1CBD122C0DFE4827 |
+-----------+------------------+-------------------------------------------+
3 rows in set (0.01 sec)

grant:授予,承认

创建账户/授权:
grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码';

# 设置权限 授予查询,插入的权限
grant select,insert on jing_dong.* to laowang@localhost with grant option;
# flush-->刷新的意思,就是将设置好的权限信息刷新之后才会生效的意思.
flush privileges;

"""

"""主从配置:

产生原因:不管是从硬件还是软件上都可能产生奔溃,一旦作为提供数据服务的数据库服务器
奔溃了,那么整个后台系统都会陷入停滞的状态而无法继续进行.对公司的业务产生停业的影响.

主从同步使得数据可以从一个数据库服务器复制到其他服务器上,在复制数据时,一个服务器充当主服务器,其余的服务器充当从服务器,因为复制是异步进行的,所以从服务器不需要一直连接着主服务器,从服务器甚至可以通过拨号断断续续地 连接主服务器.通过配置文件,可以指定复制所有的数据库,某个数据库,甚至是某个数据库里面的某个表.

使用主从同步的好处:
1.>提供服务的可用性
2.>通过增加从服务器来提高数据库的性能,在主服务器上执行写入和更新,在从服务器上向外提供读功能,可以动态地调整从服务器的数量,从而调整整个数据库的性能.
3.>提高数据安全,因为数据已复制到从服务器,从服务器可以终止复制进程,所以,可以在从服务器上备份而不破坏主服务器的相应数据.

mysql服务器之间的主从同步是基于二进制日志机制,主服务器使用二进制日志来记录数据库的变动情况,从服务器通过读取和执行该日志文件来保持和主服务器的数据一致.

在使用二进制日志时,主服务器的所有操作都会被记录下来,然后从服务器会接收到该日志的一个副本.从服务器可以指定执行该日志中的哪一类事件<例如只插入数据或者只更新数据>,默认会执行日志中的所有语句.

每一个从服务器会记录关于二进制日志的信息,文件名和已经处理过的语句,这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分,并且从服务器可以随时连接或者中断和服务器的连接.

主服务器和每一个从服务器都必须配置一个唯一的ID号,另外,每一个从服务器还需要通过change master 头语句来配置它要连接的主服务器的ip地址,日志文件名称和该日志里面的位置.


数据库备份:
mysqldump -uroot -p 数据库名 > python.sql

恢复:连接mysql,创建新的数据库
mysql -uroot -p 新的数据库名字 < python.sql

"""

"""
配置主从同步的步骤:
1.>在主服务器上,必须开启二进制日志机制和配置一个独立ID
2.>在每一个从服务器上,配置一个唯一的ID,创建一个用来专门复制主服务器数据的账号
3.>在开始复制进程之前,在主服务器上记录二进制文件的位置信息
4.>如果在开始复制之前,数据库中已经有数据,就必须先创建一个数据快照<可以使用mysqldump到处导出数据库,或者直接复制数据文件>
5.>配置从服务器要连接的主服务器的IP地址和登录授权,二进制日志文件名和位置

主和从的身份可以自己指定,我们将虚拟机ubuntu中mysql作为主服务器,可以考虑将windows中的mysql作为从服务器,在主从设置前,要保证ubuntu与windows间的网络连通,都使用桥接模式即可.

备份主服务器原有数据到从服务器

mysqldump -uroot -pmysql --all -databases --lock-all-tables > ~/master_db.sql

说明:
-u:用户名
-p:密码
--all-databases:导出所有数据库
--lock-all-tables:执行操作时锁住所有表,防止操作时候有数据修改
~/master_db.sql:导出的备份数据位置,可以自己指定
"""

"""
1.>记得先去切换路径:cd C:\Program Files\MySQL\MySQL Server 5.7\bin
2.>执行mysql -uroot -ppassword < master_db.sql 即可

问题:Access denied for user 'root'@'localhost' (using password:YES)
解决办法:
打开MySQL目录下的my.ini文件，删除最后一行的“skip-grant-tables”，保存并关闭文件。

 change master to master_host='192.168.14.141',master_user='slave',master_password='slave',master_log_file='mysql-bin.000001',master_log_pos=590;
 
 master_host:主服务器ubuntu的ip地址
 master_log_file: 前面查询到的主服务器日志文件名
 master_log_pos: 前面查询到的主服务器日志文件位置
"""


"""


START slave 
show slave STATUS

change master to master_host='192.168.17.128',master_user='slave',master_password='slave',master_log_file='mysql-bin.000001',master_log_pos=746;

STOP SLAVE IO_THREAD 停止

FOR CHANNEL;

show databases;

"""























































