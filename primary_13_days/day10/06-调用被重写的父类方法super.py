print('-----------------')
"""
调用父类被重写的方法:
当父类的方法不满足子类的需求,就在子类中重写父类方法.但是重写后就不会调用父类的方法了.子类只能调用重写后自己的方法.

如果想要调用父类已经被重写的方法,需要手动调用:

方式1:父类名.被重写的方法(sself)  # 记着要手动的传递self.父类会产生任意多个实例对象,不知道是哪个对象,所以必须加self

方式2:super(当前类类名,self).被重写的方法().单继承的时候尽量使用这个方式.self是当前所在的方法,类是当前所在的类,就可以省略掉super()里面的内容.



还想使用原来父类的方法.因为重写了之后就不再拥有父类的方法了


不需要父类的方法了,直接在子类中重写.

子类重写之后,需要父类的方法了,就使用super().

super是一个类.class.



"""


class Dog:
	def drink(self):
		print('喝白开水')

	def eat(self):  # 会提示在子类中被重写了
		# print(self)  # <__main__.XTQ object at 0x000001DC9B218B70>
		print('吃面条')


# class XTQ(Dog):
# 	def eat(self):
# 		print('吃仙丹')
#
# 		# Dog.eat(self)  # 方法1:多继承的时候才使用这个方式.如果不加self,会警告错误.因为这里是类名调用方法,所以不知道是哪个对象,所以应该加一个参数self,谁用谁就是self.


class XTQ(Dog):
	def eat(self):
		print('吃仙丹')
		# super(XTQ, self).eat()  # 会去找XTQ的下一个类,<MRO顺序>找XTQ在继承链中的父类,然后调用这个父类指定的方法.单继承时,尽量用此方式去调用,父类被重写的方法更加灵活
		super().eat()  # 简写,可以去掉XTQ和self.如果super中指定的类就是当前代码所在的类(当前代码是在XTQ这个类中),类名可以不写,如果后面的实例对象就是当前super所在方法(就是这里的eat()方法)的实例对象,实例对象参数(就是self)也可以不写.


xtq = XTQ()
# print(xtq)  # 存的一样.<__main__.XTQ object at 0x000001DC9B218B70>
xtq.eat()
