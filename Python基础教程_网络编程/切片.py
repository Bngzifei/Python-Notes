"""

Python中的序列:字符串,列表,元组
就是可以使用下标索引来取值的,就可以称之为序列



1.为甚么切片和区间会忽略最后一个元素?
	在切片和区间操作中不包含区间范围的最后一个元素是Python的风格.
	这个习惯符合Python,C和其他语言里以0作为起始下标的传统.
	这样做带来的好处是:

	1>当只有最后一个位置信息时,我们也可以快速看出切片和区间里有几个元素.
	例如:range(3)和my_list[:3]都返回3个元素

	2>当起止位置信息都可见时,我们可以快速地计算出切片和区间的长度,用后一个
	数减去第一个下标(stop-start)即可.

	3>这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分,只要
	写成my_list[:x]和my_list[x:]就可以了.


"""

l1 = [10,20,30,40,50,60]
print(l1[:2])  # 在下标为2的位置开始分割,从开始到2(没有2)  [10,20]
print(l1[2:])  #  从2开始到最后    [30,40,50,60]


"""

2.Python解释器是如何理解切片操作的?
	 众所周知,我们还可以用s[a:b:c]的形式对s在a和b之间以c为间隔取值.c的值还可以
	 为负,负值意味着反向取值.

	 a:b:c这种用法只能作为索引或者下标用在[]中来返回一个切片对象:
	 slice(a,b,c)

	 例如你可以给切片命名,就像电子表格软件(excel)里给单元格区域取名字一样.

"""

s = "bicycle"
print(s[::3])  # 输出 bye
print(s[::-1]) # 反向输出 elcycib
print(s[::-2]) # 输出 eccb  反向,隔一个取一个


"""
3.多维切片和省略
	[]运算符里还可以使用逗号分开的多个索引或者是切片,外部库NumPy里就用到了这个特性,
	二维的numpy.ndarray就可以用a[i,j]这种形式来获取,抑或是用a[m:n,k:l]的方式来得到二维切片.
	要正确处理这种[]运算符的话,对象的特殊方法__getitem__和__setitem__需要以元组的形式来接收
	a[i,j]中的索引.也就是说,如果要得到a[i,j]的值,Python会调用a.__getitem__((i,j))


	Python内置的序列类型都是一维的,因此它们只支持单一的索引,成对出现的索引是没有用的.

	省略(ellipsis)在Python解释器眼里是一个符号,而实际上他是Ellipsis对象的别名.而Ellipsis对象
	又是ellipsis类的单一实例.它可以当作切片规范的一部分,也可以用在函数的参数清单中.在NumPy中,...
	用作多维数组切片的快捷方式.如果x是四维数组,那么x[i,...]就是x[i,:,:,:]的缩写.

	除了用来提取序列里的内容,切片还可用来就地修改可变序列,也就是说修改的时候不需要重新组建序列.


	如果赋值的对象是一个切片,那么赋值语句的右侧必须是一个可迭代对象.即便只有单独一个值,
	也要把它转换成可迭代的序列.

"""