"""

利用.append和.pop方法,我们可以把列表当作栈或者队列来用(比如,
把.append和.pop(0)合起来用,就能模拟栈的"先进先出"的特点).但是,
删除列表的第一个元素(抑或是在第一个元素之前添加一个元素)之类的
操作是很耗时的,因为这些操作会牵扯到移动列表里的所有元素


collections.deque类(双向队列)是一个线程安全,可以快速从两端添加
或者删除元素的数据类型.而且如果想要有一种数据类型来存放"最近用到的
几个元素",deque也是一个很好的选择.这是因为在新建一个双向队列的时候.
你可以指定这个队列的大小,如果这个队列满员了,还可以从反向端删除过期的
元素,然后再尾端添加新的元素.示例如下:

"""

from collections import deque
dq = deque(range(10),maxlen=10)
print(dq)  # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)


dq.rotate(3)
print(dq)  # deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)

dq.rotate(-4)
print(dq)  # deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)

dq.appendleft(-1)  # deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
print(dq)


# 可以看到,指定了最大长度为10,所以当扩展3个(从右端并入)的时候,需要从左端剔除3个元素
dq.extend([11,22,33])
print(dq)  # deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)



# 同理,当准备从左端并入四个元素的时候,就需要从右端剔除4个元素
dq.extendleft([10,20,30,40])
print(dq)  # deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)

"""
参数说明:
	1.>maxlen是一个可选参数,代表这个队列可以容容纳的元素的数量,而且一旦设定,这个属性就不能修改了.
	
	2.>队列的旋转(就是dq.rotate(n))操作接受一个参数n,当n>0时,队列的最右边的n个元素会被移动到队列
	的左边.当n<0时,最左边的n个元素会被移动到右边.


	3.>当试图对一个已满(len(d)==d.maxlen)的队列做尾部添加动作的时候,它头部的元素会被删掉.

	4.>extendleft(iter)方法会把迭代器里的元素逐个添加到双向队列的左边,因此迭代器里的元素会逆序出现在
	队列里.


双向队列实现了大部分列表所拥有的方法,也有一些额外的符合自身设计的方法,比如说popleft和totate.但是为了
实现这些方法,双向队列也付出了一些代价,从队列中间户删除元素的操作会慢一些,因为它只对在头尾的操作进行了
优化.


append和popleft都是原子操作,也就是说deque可以在多线程程序中安全地当作先进先出的栈使用,而使用者不需要担心
资源锁的问题.


除了deque之外,还有其他的Python标准库也有对队列的实现.

queue
	
	提供了同步(线程安全)类Queue,LifoQueue和PriorityQueue,不同的线程可以利用这些数据类型来交换信息.这三个
	类的构造方法都有一个可选参数maxsize,它接收正整数作为输入值,用来限定队列的大小.但是在满员的时候,这些类不会
	扔掉旧的元素来腾出位置.相反,如果队列满了,它就会被锁住,直到另外的线程移除了某个元素而腾出了位置.这一特性让
	这些类很适合用来控制活跃线程的数量.

multiprocessing

	这个包实现了自己的Queue,它跟queue.Queue类似,是设计给进程间通信用的.同时还有一个专门的multiprocessing.JoinableQueue
	类型,可以让任务管理变得更方便.

asyncio
	
	Python3.4新提供的包,里面有Queue,LifoQueue,PriorityQueue和JoinableQueue,这些类受到queue和multiprocessing模块的影响,
	但是为异步编程里的任务管理提供了专门的便利.

heapq
	
	跟上面三个模块不同的是,heapq没有队列类,而是提供了heappush和heappop方法,让用户可以把可变队列当作堆队列或者优先队列来使用.

	






















"""


