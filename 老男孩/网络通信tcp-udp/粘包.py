print('---------------------------------------------------')
"""
所谓粘包问题主要还是因为接收方不知道消息之间的界限,不知道一次性提取多少字节的数据 所造成的.

此外,发送方引起的粘包是由tcp协议本身造成的.tcp为提高传输效率,发送方往往要收集足够多的数据后才发送一个tcp段.
若连续几次需要send的数据都很少,通常tcp会根据优化算法把这些数据合成一个tcp段后一次发送出去,
这样接收方就收到了粘包数据.

1.>tcp是面向连接的,面向流的,提高可靠性服务,收发两端<客户端和服务器>都要有一一成对的socket,
因此,发送端为了将多个发往接收端的包,更有效的发到对方,使用了优化方法(Nagie算法),
将多次间隔较小且数据量小的数据,合并成一个大的数据块,然后进行封包.这样,接收端就很难分辨出来了.
必须提供科学的拆包机制,即面向流的通信是无消息保护边界的.


2.>udp是无连接的,面向消息的,提供高效率服务,不会使用块的合并优化算法,
由于udp支持的是一对多的模式,所以接收端的socketkbuff<套接字缓冲区>采用了链式结构来记录每一个到达的udp包,
在每个udp包中就有了消息头,<消息来源地址,端口等信息>,这样,对于接收端来说,就容易进行区分处理了,
即面向消息的通信是有消息保护边界的.


3.>tcp是基于数据流的,于是收发的消息不能为空,这就需要在客户端和服务器都添加空消息的处理机制,
防止程序卡住,而udp是基于数据报的,即便是你输入的是空字符串<直接回车键>,那也不是空消息,udp协议会帮你封装上消息头.


发送端可以1k1k的发送数据,而接收方的应用程序也可以2k2k的接收数据,当然也有可能一次接收3k或者6k,
或者一次只提走几个字节 的数据,也就是说,应用程序所看到的数据是一个整体,或者说是一个流(stream,类似水流,看不出明显的界限),
一条消息有多少字节是不可见的,因此tcp协议是面向流的协议.这也是容易出现粘包问题的原因.而udp是面向消息的协议,
每个udp段都是一条消息,应用程序必须以消息为单位提取数据.不能一次提取任意字节的数据.需要明白的是,当对方send一条信息的时候,
无论底层怎样分段,分片,tcp协议层会把构成整条消息的数据段排序完成后才呈现在内存缓冲区.

例如,基于tcp的socket客户端往服务器端上传文件,发送时文件是按照一段一段的字节流发送的,在接收方看来,
根本不知道该文件的字节流从何处开始,在何处结束.

"""