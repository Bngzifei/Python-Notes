print('-----------------')
"""
进程池:Pool
面试常问:进程池的优势,添加方式,区别

提前准备一批进程,数量有限,重复使用.
不再需要临时创建进程.
一旦用户需要就立即响应这个需求

优势:
1.提高用户体验-响应需求
2.多个任务可以重复使用一个进程
节约进程的创建和释放的资源开销

创建和销毁进程是非常消耗资源的. 必须注意到这一点

同步:按一定秩序执行,分先后顺序.一定是先执行完哪个再去执行另外一个
异步:不管顺序,二者随便执行,执行是无序的.没有先后顺序.可能先执行A,后执行B,也可能是先执行B,后执行A.或者A和B一起执行<效果看起来是这样的>
"""
import multiprocessing
import os
import time


def worker1(no):
	for i in range(3):
		print('这是在工作进程%d中 pid:%s: ' % (no, os.getpid()))
		time.sleep(1)


# def worker2(no):
# 	for i in range(3):
# 		print('这是在工作进程%d中 pid:%s: '% (no,os.getpid()))
# 		time.sleep(1)


def main():
	# 1.创建进程池,3这个参数表示进程池里面进程<真正干活的,工作进程>的数量,如果不写,就是自己机器的cpu核心数
	pool = multiprocessing.Pool(3)

	# 2.同步apply在添加任务的时候  会等待任务执行完成才会继续往下执行  阻塞模式(同步)   专业术语:阻塞就是等待的意思,实际生活中也是这样,不堵车哪来的等待啊
	# 异步apply_async,不管任务执行完就是执行下一步了.添加任务的时候不会等待任务执行完毕效果看起来就两个任务一起执行<切换任务很快>就是在添加完任务之后不会去等任务执行了,只要添加完任务就立刻去添加下一个任务,不会去管你任务是不是执行结束了.

	# 就是把任务放进去还要等待任务执行完毕
	pool.apply(func=worker1, args=(1,))  # 包工头<控制进程>,往里面加业务
	pool.apply(worker1, args=(2,))  # 包工头<控制进程>,往里面加业务
	print('*******************')
	pool.apply_async(func=worker1, args=(3,))
	pool.apply_async(worker1, args=(4,))
	print('----------------')
	# 3.关闭池,但是里面还有人.不再允许添加新任务,但是允许里面的任务执行结束<就好比景区关门时间到了,不会放人进去,但是允许已经进去的人出来>
	pool.close()
	# 4.等待池中的进程 对应的所有任务执行完成
	pool.join()


if __name__ == '__main__':
	main()

"""
终端输出的时候会出现两个进程的pid一样,这样就说明进程池中的进程重用了,提高了资源的利用率.<这样进程池的设计目的就达到了>

"""
"""
扩展: 官方规定,不要问为啥

进程池中的进程之间,如果要通信,不能使用multiprocess.Queue类
应该使用multiprocess.Manager().Queue()

"""
