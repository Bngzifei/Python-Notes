print('-------------------面试准备---------------------')
'''
1.>引擎就是发动机,之所以这么称呼是因为这是程序中最重要的部分

2.>Ajax动态加载的工作原理:
	从网页的url加载网页的源代码之后,会在浏览器里执行javascript程序.这些程序会加载出更多的内容,并把这些内容传输到网页中显示给用户.
理解:就是访问url后得到其中的源码,源码中含有js代码,js代码在浏览器中执行(如果没有访问url中的源码,js代码就不会执行),执行之后会有更多的页面效果,
然后呈现给用户.这也是为什么有些网页直接爬取url的时候却没有数据的.不是一个静态的网页(数据不是存在这个url对应的网页代码中).

3.>处理办法:
	
4.>cookie 限制:
	一次打开一个网页会生成一个随机的cookie,如果关闭网页之后再次打开这个网页,这个cookie不会存在.那么再次设置,第三次打开仍然不存在,这就非常有可能是爬虫在工作了.

5.>join的作用:就是将list转化为str.前提是list中的每个元素必须是str类型

6.>简述Python中is和==的区别:
	Python中的对象包含三要素:id,type,value
	其中id用来唯一标识一个对象,type标识对象的类型,value是对象的值.
	is判断的是a对象是否就是b对象,是通过id来判断的.
	==是判断a对象的值是否和b对象的值相等,是通过value来判断的.

7.>简述read,readline,readlines的区别:
	1.read()每次读取整个文件,通常将读取到的文件内容存放到一个字符串变量中.即read()读取生成的文件是一个字符串类型
	
	2.readline()每次只读取文件的一行,读取到的文件内容存放到一个字符串变量中.返回的是字符串类型.
	
	3.readlines()每次按行读取整个文件内容.将读取到的内容存放到一个列表中,返回的是list类型.

8.>对list中的元素进行去重:
	使用set()先对list进行类型转换成set类型,然后再把集合类型转换成list类型.

9.>说明os.path和sys.path分别代表什么?
	sys.path是PATH环境变量,os.path是一个模块(module),这个module提供了split,join,basename等处理目录,文件名的工具.
	
10.>OSI七层协议:
	由上到下依次为:7.应用层,6.表示层,5.会话层,4.传输层,3.网络层,2.数据链路层,1.物理层
	其中7-4层定义了应用程序的功能.3-1层主要用于面向网络的端到端的数据流.
	HTTP属于应用层.

11.>什么是HTTP协议?HTTP请求有哪几种?
	HTTP(hypertext transfer protocol)是tcp/ip协议的一个应用层协议,用于定义web浏览器和web服务器之间进行数据交换的过程.客户端连接服务器之后,如果想获得服务器的某个web资源,需要遵循一定的通信格式.HTTP协议就是这个通信格式.	
	
	HTTP请求有8种:
	OPTIONS/HEAD/GET/POST/PUT/DELETE/TRACE/CONNECT
	
12.>什么是HTTP代理?作用是什么?
	Proxy Server 指代理服务器(代理就是一个替别人做事的傀儡),其功能是代理用户取得网络信息.
	实际理解就是一个网络信息的中转站.(就是一个中介)
	作用:实现各种时髦的功能,可以改善安全性,提高性能,节省费用)

13.>什么是反向代理?作用是什么?
	代理就是一个假的服务器.反向代理也是代理.
	反向代理接收发送给服务器的真实请求,但是和web服务器不同的是,反向代理可以发起和其他服务器的通信,以便按照需求定位所请求的内容.
	理解:(意思就是实现一定的客户端功能,接收了用户请求之后再去请求需要的服务器)
	
	作用:提高   访问速度比较慢的web服务器上面公共资源的  访问速度.
	在这种配置中,通常将这些反向代理称为服务器加速器.

14.>HTTPS和HTTP的区别:
	1.https协议需要ca申请证书,免费证书很少,要交费
	2.http的信息是明文传输,是超文本传输协议.https是具有安全性的ssl加密传输协议
	3.两者连接方式不同,使用的端口也不同,http是80,https是443
	4.http的连接简单,是无状态的.https是有ssl+http构建成的可加密传输.身份认证的网络协议.比http安全

15.>Python的logging模块常用的等级:
	日志级别:critical > warning > info > debug,notset
	级别越高打印的日志越少.
	debug:打印全部日志(notset等同于debug)
	info:打印info,waring,error,critical级别的日志
	waring:打印waring,error,critical级别的日志
	error:打印error,critical级别的日志
	critical:打印critical级别的日志     就是比较严苛的级别.
	
critical:adj. 鉴定的；[核] 临界的；批评的，爱挑剔的；危险的；决定性的；评论的

16.>简述Python垃圾回收机制和如何解决循环引用?
	1.引用计数 2.标记-清除 3.分代回收
	
	1.引用计数:当一个对象的引用被创建或者复制时,对象的引用计数加1;当一个对象的引用被销毁时,对象的引用计数减1.
	当引用计数为0时,就意味着对象已经没有被任何人使用了.可以将其所占用的内存进行释放了.
	具有实时性,任何内存,一旦没有指向它的引用,就会立即被回收.
	缺点:1.执行效率低. 2.存在循环引用
	
	循环引用:可以使一组对象的引用计数不为0,然而这些对象实际上并没有被任何外部对象所引用,它们之间只是相互引用.
	这意味着不会再有人使用这组对象,应该回收这组对象所占用的内存空间,然而由于相互引用的存在,每一个对象的引用计数都不是0,
	因此这些对象所占用的内存就永远不会被释放.
	容器对象(比如:list,set,dict,class,instance)都会产生循环引用
	
	理解:就是一组对象之间互相引用导致引用计数不为0,内存无法释放.实际上并没有外部对象调用这一组对象.按道理就应该释放它们占用的内存.只能手动释放内存.

	2.标记-清除:为了解决循环引用的问题.
	
	3.分代回收:
	背景:一定比例的内存块的生存周期都比较短,通常是几百万条机器指令的时间.而剩下的内存块生存周期长.
	原理:将系统中的所有内存块根据其存活时间划分为不同的集合.每一个集合就是一代.
	垃圾回收的频率随着  代  的存活时间的增大而减小.即活的越长的对象,就越不可能是垃圾,(一直使用的资源,是必需品,怎么可能是垃圾?)
	就应该减少对它的垃圾回收频率.(频率其实就是一种可能性)
	如何衡量存活时间:通常是利用垃圾回收动作来衡量,如果一个对象经过的垃圾回收的次数越多,可以得出:这个对象存活的时间就越长.
	
17.>编写函数的4个原则:
	1.函数设计尽量短小
	2.函数声明要合理,简单,易于使用
	3.函数参数应该考虑向下兼容
	4.一个函数只做一件事情,尽量保证函数语句粒度的一致性
	理解:粒度  其实就是衡量函数功能的复杂程度.就是敏感度
	
	
18.>使用标准的HTTP方法:
	GET -->  select:从服务器获取资源
	POST --> create:在服务器新建资源(实际就是管理员向服务器发帖,或者qq空间上传照片的过程)
	PUT --> update: 在服务器更新资源(就是覆盖掉之间已经上传的资源)
	DELETE --> delete:从服务器删除资源
	
19.>如何判断一个Python对象的类型:
	type()
	isinstance()

20.>写出ip的正则表达式:
	说明:ipv4的ip地址都是 (1~255).(0~255).(0~255).(0~255) 这种格式
	
	eg1:
	"^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."
	+"(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
	+"(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
	+"(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"

21.>写出list的交集和差集:
	将list转成set后进行交集,差集运算,再把对应结果转成list返回
	
A = {1, 2, 3}
B = {1, 2, 4}

print((A | B))  # 并集
print((A & B))  # 交集
print((A - B))  # 差集
print((A ^ B))  # 对称差集  {3, 4}  就是并集 - 交集

22.>list去重:转换成set处理.set排序:转换成list处理
	
23.>ajax请求页面如何加载:
	ajax可以实现局部刷新,即无刷新.是指整个页面不刷新,只是局部刷新.ajax可以自己发送http请求.
	不通过浏览器的地址栏,所以页面整体不会刷新,ajax获取到后台数据,更新页面显示数据的部分,这样就做到了页面局部刷新.
	
24.>Selenium的作用:
	是一个web自动化测试工具.直接运行在浏览器上.支持所有主流浏览器.
	可以根据我们的指令,让浏览器自动加载页面,获取需要的数据.甚至页面截屏,或者判断网站上某些动作是否发生.
	自己不带浏览器,不支持浏览器的功能.需要和浏览器结合在一起才能使用.
	但是,我们需要让它内嵌在代码中执行,所以使用PhantomJS这个工具代替真实的浏览器.
	
	理解: Selenium: 硒    Phantom:中文意思是 幽灵；幻影；虚位	
	
25.>PhantomJS的作用:
	是一个基于Webkit的无界面浏览器(就是没有图形化界面),它会把网站加载到内存并且执行页面上的js,因为没有图形化界面,
	所以运行起来比一般意义上的浏览器要更加高效.
	
	作用:可以将Selenium 和 PhantomJS 结合在一起,就可以运行一个很强大的网络爬虫了.这个爬虫可以处理js,cookie,headers以及任何真实用户需要做的事情.

26.>什么是lambda函数?它有什么好处:
	lambda表达式就是一个函数,可以赋值给一个变量.
	好处:
	1.只是一个表达式,函数体比def简单
	2.lambda的主体是一个表达式,而不是代码块,只能在lambda表达中封装有限的逻辑
	3.lambda表达式起到一个函数速写的作用,允许在代码内嵌入一个函数的定义
	
27.>dict comprehensions是什么?
	
	理解:comprehensions:  包含,理解
	
	是Python的字典推导式
	比如:可以实现key和value的对调
	d = {'a': 1, 'b': 2}
	dl = {v: k for k, v in d.items()}

28.>常用的设计模式:
	创建型:
	1.Factory Method(工厂方法)
	2.Abstract Factory(抽象工厂)
	3.Builder(建造者)
	4.Prototype(原型)
	5.Singleton(单例)
	6.Adapter Class/Object(适配器)
	7.Bridge(桥接)
	8.Composite(组合)
	9.Decorator(装饰)
	10.Facade(外观)
	11.Flyweight(享元)
	12.Proxy(代理)
	行为型:
	1.Interpreter(解释器)
	2.Template Method(模板方法)
	3.Chain of Responsibility(责任链)
	4.Command(命令)
	5.Iterator(迭代器)
	6.Mediator(中介者)
	7.Memento(备忘录)
	8.Observer(观察者)
	9.State(状态)
	10.Strategy(策略)
	11.Visitor(访问者)

29.>关键字yield的用法:
	yield 就是保存当前程序的执行状态.
	
30.>装饰器应用场景:
	经常被用于有切面需求的场景,较为经典的有 插入日志,性能测试,事务处理等.
	作用:为已经存在的代码在不修改该代码的情况下添加额外的功能.

31.>可变类型,不可变类型:
	可变:list dict
	不可变:int str tuple set
	主要区分是指内存中的值是否可以被改变

32.>Python里面range和xrange的区别:
	py2中range和xrange的参数和用法相同.
	只是xrange()返回的是一个xrange对象.这个对象可以按需生成参数指定范围内的数字,(实质就是一个生成器)
	由于xrange对象是按需生成单个的元素,而不是像py2中的range那样,首先创建整个list.
	所以,在相同的范围内,xrange占用的内存空间将更小.xrange也更快.因为其本质就是一个生成器.
	
	py2中range()返回的是一个list
	py3中range()返回的是一个range class.是一个range类
	
33.>编写爬虫的常用模块或者框架?请说明一个爬虫的行为步骤
	步骤:
	1.获取网页
	2.提取数据
	3.高效抓取数据
	4.持续抓取数据(增量式爬虫)
	5.爬虫和反爬虫和反反爬虫的斗争
	
34.>排序算法有哪些?
	冒泡排序,快排,归并排序
		
35.>对cookie的理解,如何处理没有cookie登录的问题:
	cookie是由HTTP服务器设置的,保存在浏览器中.但是http协议是一种无状态协议,在数据交换完成后,服务器和客户端的连接就会关闭,
	每次交换数据都需要建立新的连接.就像我们去超市买东西,没有积分卡的情况下,买完东西之后,超市不会有我们的任何消费信息.
	但是如果有积分卡,那么每次购买都会有我们的消费信息.cookie就是这里的积分卡,可以保存积分,商品就是我们的个人信息.
	超市就是服务器,http协议就是买东西交易的过程.
	如何处理:如果遇到没有cookie,使用PhantomJS 和 Selenium 进行登录. 

cached:贮藏  cache:贮存

36.>如何解决验证码的问题使用哪些模块,使用过哪些人工打码平台?
	
	PIL ,pytesser, tesseract
	平台:云打码,答题吧打码,挣码,斐斐打码,若快打码

37.>对scrapy_redis的理解:
	scrapy_redis是一个基于redis的scrapy组件,通过它可以快速实现简单的分布式爬虫程序.该组件本质上提供了三大功能:
	1.scheduler - 调度器
	2.dupefilter - URL去重规则(被调度器使用)
	3.pipeline - 数据持久化

38.>session和cookie的区别:
	1.cookie数据存放在客户端的浏览器上,session数据存放在服务器上
	2.cookie不是很安全,别人可以通过分析存放本地的cookie并进行cookie欺骗的操作.
	3.session会在一定时间内保存在服务器上.当访问增多,会占用服务器资源,削弱服务器的性能.如果考虑减轻服务器压力,应该使用cookie
	4.单个cookie保存的数据不能超过4K,很多浏览器都限制一个站点最多保存20个cookie
	理解:就是一个cookie相当于一个身份证,限购4K条数据,一个浏览器限购20个身份证(类似一个大巴车最多载70个人)
	5.可以考虑将登陆信息等比较重要的数据存放为session.其余的存放为cookie
	
39.>Python里面如何生成随机数:
	使用random模块
	1.生成随机整数:
		random.randint(a,b): 返回随机整数x, a<=x<=b, 两边界都可以取到
		random.randrange(a,b):返回随机整数x,a<=x<b,可以取到左边界,取不到右边界
	2.生成随机实数:random.random():返回随机小数x,0<=x<1,没有参数,默认范围就是[0,1)
	3.生成指定范围的随机小数:random.uniform(a,b):返回随机小数x,x在 [a, b) or [a, b]范围内.具体取决于round


40.>OOP编程三大特点?多态应用的基础是什么?
	1.>封装:将一个类的使用和实现过程分开,只保留部分接口和方法与外部联系
	2.>继承:子类自动继承父类中的属性和方法,并且可以添加新的属性和方法.或者对父类方法和属性进行重写.实际效果是增加了代码的可重用性.
	3.>多态:多个子类中虽然都具有同一个方法,但是这些子类实例化的对象在调用这些相同方法后却可以获得完全不同的结果.实际效果是增强了软件的灵活性.
	(多态的特征依赖于继承)

41.>抽象类和接口类的区别和联系:(这是java特有的,可以不看了)
	1.抽象类:规定了一系列方法,并规定了必须由继承类实现的方法.由于有抽象方法的存在,所以抽象类不能实例化.
	可以将抽象类理解为毛坯房,门窗,墙面的样式由你自己来决定.所以抽象类和作为基类的普通类相比,约束性更强.
	2.接口类:类似于抽象类.在接口中定义的方法,必须由引用类实现.但是,和抽象类的根本区别在于用途:与不同个体间沟通的方法.
	例如,你要进入宿舍需要有钥匙,这个钥匙就是你与宿舍的接口.你的室友也有这个接口,所以它也可以进入宿舍.你使用手机和别人通话.
	那么手机就是你与他人之间交流的接口.
	理解:接口就是中介的作用,是一个连接通信双方的桥梁
	
	区别和联系:
	1.接口是抽象的变体.接口中所有的方法都是抽象的.而抽象类中可以有非抽象方法.抽象类是声明方法的存在,而不去实现它.
	2.接口可以继承,抽象类不行.
	3.接口定义方法,没有实现的代码,而抽象类可以实现部分方法.
	4.接口类中基本数据类型为static,而抽象类不是
	5.可以在一个类中同时实现多个接口
	6.接口的使用方式通过implements关键字进行,抽象类则是通过extends关键字进行.

implements: 执行，履行；贯彻，落实；使生效

42.>请描述方法重载与方法重写:
	1.方法重载:是在一个类里面,方法名字相同,而参数不同.返回值类型可以相同也可以不同.
	重载是让类以统一的方式处理不同类型数据的一种手段.
	2.方法重写:子类继承父类方法后,对继承的方法进行一定的修改.方法重写又叫做方法覆盖.

-----------------------------------------------复习:day01-----------------------------------------------------------------------	
sys.argv  命令行 获取参数列表

import sys
sys.argv  返回值是一个列表

判断语句:优先判断从逻辑推理发生可能性更大的情况,可以提高代码的执行效率
	三元运算符  x if x>9 else 9  结合 return 使用 例如:return x if x>9 else 9
	判断多个条件:
	if all([1==1,2==3]):  所有都成立才会执行下面
		pass
	
	循环嵌套最多三层
	
	内建函数的执行效率都很高,比自己写的那些算法要高.比如list的reverse方法就比
	list[::-1]要高.
	
	修改可变类型的全局变量可以不使用global, 因为可变类型是引用传递
	
	超过三次的循环考虑是否可以使用递归函数替代
	
	深拷贝对生成器是无效的,更不用说浅拷贝了
	
	最常见的生成器:range()
	
	range()也是一个生成器,py3中的range()代替了py2中的range()和xrange()
	
	py2中有range()和xrange()两种,xrange()返回的是一个xrange类型,range()返回的是list类型
	
	py3中的range()返回的是一个range 类.
	








	
'''

# -----------------------1.join的作用:-------------------------------
# list1 = ['1', '2', '3', '4']  # 必须保证list里面的元素类型是str才可以使用join进行转化
# for i in list1:
# 	pass
# print(''.join(list1))  # 输出为:1234
# print(type(''.join(list1)))  # <class 'str'>

# -------------------------2.list中元素去重:---------------------------

# list1 = [1, 2, 2, 34, 5, 61, 1, 8, 9, 8, 0]
# a = set(list1)
# print(list(a))  # 输出:[0, 1, 2, 34, 5, 8, 9, 61]

# -------------------------3.写出list的交集和差集:-----------------------
# l1 = [1, 2, 3]
# l2 = [2, 3, 4]
#
# s1 = set(l1) & set(l2)  # 交集
# s2 = set(l1) | set(l2)  # 并集
# s3 = set(l1) - set(l2)  # 差集
# s4 = set(l1) ^ set(l2)  # 对称差集:并集 - 交集
#
# print('交集:%s,并集:%s,差集:%s,对称差:%s' % (list(s1),list(s2), list(s3), list(s4)))
# # 输出为 : 交集:[2, 3],并集:[1, 2, 3, 4],差集:[1],对称差:[1, 4]

# ---------------------------4.对list排序:-----------------------------
# a = [1, 2, 4, 2, 45, 7, 10, 5, 5, 7, 8, 9, 0, 3]
# # ................方式一:............
# a.sort()  # 这是方法,a独有的.排序后返回值是None  默认 reverse=False   对应的是升序
# print(a)  # 所以直接输出a就行  在原有的列表上进行排序
# # [0, 1, 2, 2, 3, 4, 5, 5, 7, 7, 8, 9, 10, 45] 默认是升序排
# # 降序排
# a.sort(reverse=True)
# print(a)  # [45, 10, 9, 8, 7, 7, 5, 5, 4, 3, 2, 2, 1, 0]
# # ............方式二:...............
# l1 = sorted(a, reverse=False)  # 这是函数了(函数是共有的) 默认reverse=False 是升序,返回一个新的列表
# l2 = sorted(a, reverse=True)  # 返回一个新列表
# print(l1)
# print(l2)

# --------------------字典推导式:---------------------------
# d = {'a': 1, 'b': 2}
# dl = {v: k for k, v in d.items()}
# print(dl)  # 输出:{1: 'a', 2: 'b'}
# 理解:将字典的key,value进行对调,即原来的key变成value,value变成key

# print(range(1,10))
# print(type(range(10)))

# a = range(10)
# print(a)
# print(type(a))

# -------------------------生成随机数--------------------------->
# import random
#
# x = random.randrange(1, 3)
# y = random.randint(1, 3)
# z = random.random()  # 默认是[0,1)的范围, 没有参数
# u = random.uniform(1, 2)  # 返回指定范围的小数.
# print(x)
# print(y)
# print(z)
# print(u)
# help(random.random)
"""
help()输出: 对一个函数或方法或变量或类或模块的描述说明<实际输出的内容就是这些代码的注释内容>
Help on built-in function random:

random(...) method of random.Random instance
    random() -> x in the interval [0, 1).

"""


# -------------------------------冒泡排序:---------------------------->
# bubble:n. 气泡，泡沫，泡状物；透明圆形罩，圆形顶
# 在打印图形中,外循环控制行数,内循环控制列数<即一行有几个元素>
# def bubble_sort(nums):
# 	# 注意:这里的len(nums) - 1不是通常意义的生成元素的索引.形式一样,表示的含义不同.
# 	for i in range(len(nums) - 1):  # 外循环控制排序次数,因为是相邻两个进行比较,所以比较次数就是 元素个数 - 1<类似于5个手指有4个空隙>
# 		for j in range(len(nums) - i - 1):  # 内循环控制列表下标,即控制列表元素
# 			# len(nums) - i - 1 这里的含义是每次比较之后,需要进行比较的元素的索引.
# 			# 并不是通俗理解的元素索引.是每一次排序之后需要进行排序的元素的索引.
# 			# 因为排过序的元素在下次排序的时候不需要进行排序操作.
# 			if nums[j] > nums[j + 1]:
# 				nums[j], nums[j + 1] = nums[j + 1], nums[j]
# 			print('----', nums)
# 		print('****', nums)
#
# 	# 循环结束,返回排序结果
# 	return nums
#
#
# list1 = [2, 1, 0,5,8,9]
# print(bubble_sort(list1))
# 输出:[2, 3, 4, 5, 6, 9, 12, 56]
# ----------------------------冒泡排序练习:-------------------------------
def sort_maopao(num):
	"""冒泡排序"""
	for i in range(len(num) - 1):  # i是排序次数
		for j in range(len(num) - i - 1):  # j是列表元素的索引
			if num[j] > num[j + 1]:
				num[j], num[j + 1] = num[j + 1], num[j]
	return print(num)


num1 = [1, 48, 32, 1, 9]

sort_maopao(num1)
