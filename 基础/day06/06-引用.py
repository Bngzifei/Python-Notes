print('引用:')
"""
普通变量引用:变量与变量之间的赋值,不是值的传递,而是值对应的内存地址的传递

类似银行的主副卡 ,账户是唯一的,使用者是2个
内存地址唯一
"""

# a = 10
# b = a
# c = 10
# print(id(a))  # 1773691392
# print(id(b))  # 1773691392
# print(id(c))  # 1773691392  缓存的原因造成了这里c重新赋值的时候和a的一样
"""可变类型变量的引用
如果把一个列表直接赋值给另外一个变量,当操作其中一个变量(增删改),另外一个变量中看到的列表数据也会跟着变化

直接定义出来的两个数据就算他们的值一样,地址绝对不一样



"""

# list1 = [1, 2]
# list2 = list1
#
# list2.append(3)
# list3 = [1,2,3]
# print(id(list3))  # 2560357837768 新写的列表,即使和原来的内存地址和list2的就不一样的
# print(id(list1))  # 2558466141192
# print(id(list2))  # 2558466141192
# print(list1)  # [1, 2, 3]  主副卡的关系(主增加300万,副卡也能查到,副卡删了300万,主卡也是)
# print(list2)


"""元组:元组中的元素不能被替换掉,但是如果元组中的元素是可变类型的时候,数据不能换掉(就是这个元素不能被替换),但是可以对可变类型的元素(在它内部增.删.改)增删改.
这是一个笔试题"""
list1 = [10, 20]
tuple1 = (list1, 3)
list1.append(30)
# tuple1[0] = 39  # 这里的意思就是拿39去换掉list1,但是元组不支持这么操作,所以是错误的
tuple1[0].append(37)  # ([10, 20, 30, 37], 3)
print(tuple1)  # 地址没变,是元组中的数据变了,因为里面的list可以继续装数据的时候,这个list的地址没变,所以元组也OK

# 多线程网络这些东西以后会问到,但是用的不多


"""默认参数的值尽量不要用可变类型:如果默认 参数的值是可变类型,将来默认参数的值会随着多次调用发生修改"""
# 字典也是一样的
# def func1(list1=[]):  # 警告:Default argument value is mutable  默认参数是可变类型
# 	list1.append(2)
# 	print(list1)
#
#
# func1([1])  # list1 = [1],[1,2]
# func1()  # [2,2] 函数名不会释放,所以还是在原来的[]里面加2
# func1()  # [2,2,2]
# func1()  # [2,2,2]
"""小数字缓存池"""
# 内存速度跟不上cpu,拖累了cpu的效率
# 复制内存的数据到cpu上面,称之为缓存(cache).但是缓存有限
# 主频:类似内存的存储空间(表示可以存储的空间),正常情况都是单核运行.大型游戏才开多核
# 解释器做了优化,-5 ~ 256 区间的数字,在运行的那一刻全部在内存上面开辟了空间.因为cpu在开辟空间和关闭空间是一个十分耗时的工作,会导致发热,结果就是会导致性能降低(热衰减)

# a = 10 * 10
# b = 100
#
#
# print(id(a))
# print(id(b))  # 本该不一样,就是因为这些常用的数字解释器优化了
#
#
# """
# 1773497664
# 1773497664"""


# a = 10 * 100  # 超过了-5 ~ 256 ,所以不一样
# b = 1000
#
#
# print(id(a))
# print(id(b))
# """
# 2547883936368
# 2547883691792"""
#
# # 但是在交互式中测试的结果不一样
#
# a = -6  # 超过了-5 ~ 256 ,所以不一样
# b = -6
#
#
# print(id(a))
# print(id(b))

# 地址一样,值肯定相同.地址不一样,值可能一样,也可能不一样.
# 列表字典这种是可变的,所以没有缓冲的功能

# Pycharm不要打开所有文件,因为加载慢.
"""字符串缓存最大位数20位"""
a = 'hellohellohellohello'
b = 'hellohellohellohell' + 'o'
c = 'hellohellohellohell' + 'ol'

print(id(a))
print(id(b))
print(id(c))

# a = 1917725739600
# b = 1917725739600
# c = 1917725739528