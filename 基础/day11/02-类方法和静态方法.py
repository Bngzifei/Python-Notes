"""

1> 默认我们在类中定义的方法全部都是实例方法,属于实例对象. 会自动生成self形参,并且调用时,会自动把调用此方法的实例对象传给self.

2> 类方法:在@classmethod修饰符下面定义的第一个方法就是类方法,类方法会自动生成cls形参,并且调用类方法时,会自动传递调用此方法的类对象.

3> Python中的所有方法 都可以用类名去调用,或者实例对象去调用.实际开发中尽量去区分实例对象和类对象.

4> 实例对象只能对应一个类对象,但是一个类对象可以有无数个实例对象.

5>类方法和类属性尽量使用类对象去操作,其他都使用实例对象.
除了调用父类被重写的方法时,可能会用类对象调用实例方法,此时需要注意手动传self.


当在某个方法中,只需要类对象,不用实例对象,尽量定义成类方法.

默认生成的都是实例对象,实例方法.

应用场景:当不需要实例对象,只需要修改类属性的时候就使用类对象.

静态方法应用:在方法内部,不需要使用类对象,也不需要使用实例对象,就使用静态方法.

静态方法使用:如果在方法里面不用实例对象,也不用类对象,尽量改成静态方法.因为不会生成cls,self的形参.并且在调用的时候也不会自动传递实例对象或类对象.    目的是省内存.



屏蔽在方法属性里面,私有  ----> 叫 封装.

方法里面不需要自动传,自动调用的时候使用静态方法

"""


class Dog:
    __type = '狗'  # 类属性,__设置成私有属性,以免外部随意修改这个属性值.

    @classmethod  # 修饰符,  语法糖  和装饰器类似  这样的目的是为了代码复用
    def set_type(cls, type_str):  # cls是class的简写.
        print(cls)  # <class '__main__.Dog'>
        cls.__type = type_str
        print('----')

    # 如果在方法里面不用实例对象,也不用类对象,尽量改成静态方法.因为不会生成cls,self的形参.并且在调用的时候也不会自动传递实例对象或类对象
    @staticmethod
    def drink():  # 因为里面不使用self,所以不会生成self的内存空间.技术提升之后要使用.
        print('喝红酒')


# Dog.set_type('ii')
dog1 = Dog()
Dog.type = '大朗'
dog1.set_type('小花')
dog1.set_type('大朗')
print(Dog.type)
