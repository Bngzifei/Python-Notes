"""
1>.__all__ = ['func1', 'count']  # 控制   from 模块名 import *    这种导入方式时导入的内容

2>.__name__就是控制文件被作为模块使用后,不执行相应的测试代码

"""
__all__ = ['func1', 'count']  # 控制   from 模块名 import *    这种导入方式时导入的内容


def func1():
	print('这是一个函数')


count = 10  # 全局变量


class Dog:
	def eat(self):
		print('吃馒头')


print(__name__)  # __name__就是控制文件被作为模块使用后,不执行相应的测试代码

# if __name__ == '__main__':
# 	func1()  # 放到 if 里面,只要是调用的时候,调用的部分都加到if 里面
# 	print(count)
"""
把某个文件当成模块使用后,可能会执行到一些测试代码,或者不必要执行的代码.
就是别人不会需要你在写了某个功能模块时候具体的执行结果,只是需要这个模块的算法,功能,实现的过程,方法.别人导入这个模块的时候是要
干自己的事情,所以肯定不需要执行这个模块中的已经调用的执行结果.只需要导入模块,不执行.等到自己需要的时候才会在自己的部分调用这个
模块的某个方法,函数,等等.

"""
# func1()  # 测试代码
# print(count)  # 测试代码,别人不需要我的测试代码的执行结果.

# if __name__ == '__main__':   快捷方式: 直接main 后加回车键
#     pass

# 主动执行  --> main 类型 自己执行
# 被动执行 --> 模块名  别人调用